{
  "createdAt": "2025-11-07T16:03:52.061Z",
  "id": "bTeLj5qOKQo9PDMO",
  "name": "sw_xp_quest",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "usuario_id"
            },
            {
              "name": "quests_personalizadas"
            },
            {
              "name": "atualizacoes_status"
            }
          ]
        }
      },
      "id": "e4d9986b-55f9-4e07-93f0-bb2c03f40bf7",
      "name": "start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        592,
        272
      ]
    },
    {
      "parameters": {
        "jsCode": "const item = $input.item.json || {};\n\nconst parseList = (value) => {\n  if (!value) return [];\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') {\n    try {\n      const parsed = JSON.parse(value);\n      if (Array.isArray(parsed)) return parsed;\n    } catch (error) {}\n  }\n  return [];\n};\n\nconst usuarioId = item.usuario_id;\nif (!usuarioId) {\n  throw new Error('usuario_id obrigatório');\n}\n\nconst quests = parseList(item.quests_personalizadas);\nconst updates = parseList(item.atualizacoes_status);\n\nreturn [{\n  json: {\n    usuario_id: usuarioId,\n    novas_quests: quests,\n    atualizacoes: updates\n  }\n}];"
      },
      "id": "92bf9d45-d388-48e0-a7c2-8a4802c564ab",
      "name": "Normalizar Entrada",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        816,
        272
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "71Ru87yaRA5SNjOQ",
          "mode": "list",
          "cachedResultUrl": "/workflow/71Ru87yaRA5SNjOQ",
          "cachedResultName": "sw_calcula_jornada"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "usuario_id": "={{ $('start').first().json.usuario_id }}"
          },
          "matchingColumns": [
            "usuario_id"
          ],
          "schema": [
            {
              "id": "usuario_id",
              "displayName": "usuario_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "a03870e0-f2df-4b91-9127-881a5df03be1",
      "name": "Atualizar Jornada",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        2432,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH quests AS (\n  SELECT\n    uq.id,\n    uq.status,\n    uq.ativado_em,\n    uq.atualizado_em,\n    uq.catalogo_id,\n    uq.quest_estagio,\n    COALESCE(uq.config, '{}'::jsonb) AS config\n  FROM public.usuarios_quest uq\n  WHERE uq.usuario_id = $1::uuid\n)\nSELECT\n  u.usuario_id,\n  u.nivel_atual,\n  u.titulo_nivel,\n  u.xp_total,\n  u.total_quests_concluidas,\n  u.total_quests_personalizadas,\n  u.sequencia_status,\n  COALESCE(jsonb_agg(quests) FILTER (WHERE quests.id IS NOT NULL), '[]'::jsonb) AS quests_ativas\nFROM public.usuarios_conquistas u\nLEFT JOIN quests ON TRUE\nWHERE u.usuario_id = $1::uuid\nGROUP BY\n  u.usuario_id,\n  u.nivel_atual,\n  u.titulo_nivel,\n  u.xp_total,\n  u.total_quests_concluidas,\n  u.total_quests_personalizadas,\n  u.sequencia_status;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id ] }}"
        }
      },
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      },
      "id": "1b129742-7484-45b4-be33-4a1e2d9ef815",
      "name": "Buscar Estado e Quests",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1072,
        272
      ]
    },
    {
      "parameters": {
        "jsCode": "const entradaLista = $items(\"Normalizar Entrada\") || [];\nconst entrada = (entradaLista[0] && entradaLista[0].json) || {};\nconst estado = $input.item.json || {};\n\nreturn [{\n  json: {\n    usuario_id: entrada.usuario_id,\n    novas_quests: Array.isArray(entrada.novas_quests) ? entrada.novas_quests : [],\n    atualizacoes: Array.isArray(entrada.atualizacoes) ? entrada.atualizacoes : [],\n    estado_inicial: estado\n  }\n}];"
      },
      "id": "5b04b7df-c9d5-40a7-821c-f52c5c4280a3",
      "name": "Preparar Operacoes",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1296,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT $1::uuid AS usuario_id,\n  $2::jsonb AS novas_quests,\n  $3::jsonb AS atualizacoes,\n  $4::jsonb AS estado_inicial\n),\nverificar_quests AS (\n  SELECT COUNT(*) AS total_quests\n  FROM public.usuarios_quest uq\n  WHERE uq.usuario_id = (SELECT usuario_id FROM payload)\n    AND uq.status NOT IN ('cancelada', 'vencida')\n),\nbuscar_reflexao_diaria AS (\n  SELECT id\n  FROM public.quests_catalogo\n  WHERE codigo = 'reflexao_diaria'\n  LIMIT 1\n),\ncriar_quest_inicial AS (\n  INSERT INTO public.usuarios_quest (\n    id,\n    usuario_id,\n    catalogo_id,\n    status,\n    quest_estagio,\n    ativado_em,\n    concluido_em,\n    config,\n    recorrencias\n  )\n  SELECT\n    gen_random_uuid(),\n    (SELECT usuario_id FROM payload),\n    brd.id,\n    'ativa',\n    'fazendo',\n    NOW(),\n    NULL,\n    jsonb_build_object(\n      'titulo', 'Reflexão Diária',\n      'descricao', 'Conversa com seu Assistente de reflexão',\n      'prioridade', 'alta',\n      'recorrencia', 'diaria',\n      'conversa', true,\n      'contexto_origem', 'sistema'\n    ),\n    jsonb_build_object(\n      'tipo', 'diaria',\n      'janela', jsonb_build_object(\n        'inicio', CURRENT_DATE::text,\n        'fim', (date_trunc('week', CURRENT_DATE) + INTERVAL '6 days')::date::text\n      ),\n      'dias', (\n        SELECT jsonb_agg(\n          jsonb_build_object(\n            'data', dia::date::text,\n            'xp_previsto', 10\n          ) ORDER BY dia\n        )\n        FROM generate_series(\n          CURRENT_DATE,\n          (date_trunc('week', CURRENT_DATE) + INTERVAL '6 days')::date,\n          '1 day'\n        ) AS dia\n      )\n    )\n  FROM buscar_reflexao_diaria brd\n  CROSS JOIN verificar_quests vq\n  WHERE vq.total_quests = 0\n  RETURNING id\n)\nSELECT\n  (SELECT usuario_id FROM payload) AS usuario_id,\n  payload.novas_quests,\n  payload.atualizacoes,\n  payload.estado_inicial,\n  COALESCE((SELECT COUNT(*) FROM criar_quest_inicial), 0) AS quest_inicial_criada\nFROM payload;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id, JSON.stringify($json.novas_quests || []), JSON.stringify($json.atualizacoes || []), JSON.stringify($json.estado_inicial || {}) ] }}"
        }
      },
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      },
      "id": "df21bd43-d75a-4021-909b-2c3176f77366",
      "name": "Verificar e Criar Quest Inicial",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1536,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT\n    $1::uuid AS usuario_id,\n    $2::jsonb AS novas_quests,\n    $3::jsonb AS atualizacoes,\n    $4::jsonb AS estado_inicial\n),\ncriar_conquistas_se_nao_existe AS (\n  INSERT INTO public.usuarios_conquistas (usuario_id, xp_total, nivel_atual, titulo_nivel, xp_proximo_nivel, total_quests_concluidas, total_quests_personalizadas, atualizado_em)\n  SELECT\n    payload.usuario_id,\n    0,\n    1,\n    (SELECT nome FROM public.jornada_niveis WHERE nivel = 1 LIMIT 1),\n    (SELECT xp_proximo_nivel FROM public.jornada_niveis WHERE nivel = 1 LIMIT 1),\n    0,\n    0,\n    NOW()\n  FROM payload\n  WHERE NOT EXISTS (\n    SELECT 1 FROM public.usuarios_conquistas uc WHERE uc.usuario_id = payload.usuario_id\n  )\n  ON CONFLICT (usuario_id) DO NOTHING\n  RETURNING usuario_id\n),\nbuscar_quest_custom AS (\n  SELECT id FROM public.quests_catalogo WHERE codigo = 'quest_custom' LIMIT 1\n),\nrows AS (\n  SELECT\n    payload.usuario_id,\n    rec->>'titulo' AS titulo,\n    rec->>'descricao' AS descricao,\n    rec->>'contexto_origem' AS contexto_origem,\n    COALESCE(rec->>'prioridade', 'media') AS prioridade,\n    COALESCE(rec->>'recorrencia', 'unica') AS recorrencia,\n    (rec->>'prazo_inicio')::date AS prazo_inicio,\n    (rec->>'prazo_fim')::date AS prazo_fim,\n    COALESCE(rec->>'status_inicial', 'pendente') AS status_inicial,\n    COALESCE(rec->'payload_extra', '{}'::jsonb) AS payload_extra,\n    COALESCE((rec->>'xp_recompensa')::int, 10) AS xp_recompensa,\n    COALESCE(\n      NULLIF((rec->>'catalogo_id')::uuid, NULL),\n      (SELECT id FROM buscar_quest_custom)\n    ) AS catalogo_id\n  FROM payload,\n       jsonb_array_elements(payload.novas_quests) rec\n),\nrecorrencias_quest AS (\n  SELECT\n    rows.*,\n    CASE\n      WHEN rows.recorrencia != 'unica' AND rows.prazo_inicio IS NOT NULL AND rows.prazo_fim IS NOT NULL THEN\n        jsonb_build_object(\n          'tipo', rows.recorrencia,\n          'janela', jsonb_build_object('inicio', rows.prazo_inicio::text, 'fim', rows.prazo_fim::text),\n          'dias', (\n            SELECT jsonb_agg(\n              jsonb_build_object(\n                'data', dia::date::text,\n                'xp_previsto', rows.xp_recompensa\n              ) ORDER BY dia\n            )\n            FROM generate_series(rows.prazo_inicio, rows.prazo_fim, '1 day') AS dia\n          )\n        )\n      ELSE NULL\n    END AS recorrencias\n  FROM rows\n),\ninserted AS (\n  INSERT INTO public.usuarios_quest (\n    id,\n    usuario_id,\n    catalogo_id,\n    status,\n    quest_estagio,\n    ativado_em,\n    concluido_em,\n    config,\n    recorrencias\n  )\n  SELECT\n    gen_random_uuid(),\n    rq.usuario_id,\n    COALESCE(rq.catalogo_id, (SELECT id FROM buscar_quest_custom)),\n    rq.status_inicial,\n    'a_fazer',\n    NOW(),\n    NULL,\n    jsonb_build_object(\n      'titulo', rq.titulo,\n      'descricao', rq.descricao,\n      'prioridade', rq.prioridade,\n      'recorrencia', rq.recorrencia,\n      'contexto_origem', rq.contexto_origem,\n      'payload_extra', rq.payload_extra\n    ),\n    rq.recorrencias\n  FROM recorrencias_quest rq\n  WHERE COALESCE(rq.catalogo_id, (SELECT id FROM buscar_quest_custom)) IS NOT NULL\n  RETURNING id\n),\natualiza_estado AS (\n  UPDATE public.usuarios_conquistas\n  SET\n    total_quests_personalizadas = total_quests_personalizadas + (SELECT COUNT(*) FROM inserted),\n    atualizado_em = NOW()\n  WHERE usuario_id = (SELECT usuario_id FROM payload)\n  RETURNING total_quests_personalizadas\n)\nSELECT\n  payload.usuario_id,\n  payload.novas_quests,\n  payload.atualizacoes,\n  payload.estado_inicial,\n  COALESCE((SELECT COUNT(*) FROM inserted), 0) AS novas_inseridas\nFROM payload;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id, JSON.stringify($json.novas_quests || []), JSON.stringify($json.atualizacoes || []), JSON.stringify($json.estado_inicial || {}) ] }}"
        }
      },
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      },
      "id": "d04134ef-f531-4b8d-b93d-9a2b891da8c5",
      "name": "Inserir Instancias",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1776,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT\n    $1::uuid AS usuario_id,\n    $2::jsonb AS atualizacoes,\n    $3::jsonb AS estado_inicial,\n    $4::jsonb AS novas_quests\n),\nupdates AS (\n  SELECT\n    payload.usuario_id,\n    (rec->>'instancia_id')::uuid AS instancia_id,\n    COALESCE(rec->>'novo_status', 'pendente') AS novo_status,\n    COALESCE((rec->>'xp_extra')::int, 0) AS xp_extra,\n    COALESCE((rec->>'data_referencia')::date, CURRENT_DATE) AS data_referencia\n  FROM payload,\n       jsonb_array_elements(payload.atualizacoes) rec\n  WHERE rec ? 'instancia_id'\n),\nalvos AS (\n  SELECT\n    uq.id,\n    uq.usuario_id,\n    uq.status AS status_atual,\n    uq.catalogo_id,\n    uq.quest_estagio,\n    uq.concluido_em AS concluido_em_anterior,\n    uq.recorrencias,\n    updates.novo_status,\n    updates.xp_extra,\n    updates.data_referencia,\n    COALESCE(uq.config, '{}'::jsonb) AS config\n  FROM updates\n  JOIN public.usuarios_quest uq ON uq.id = updates.instancia_id\n  WHERE uq.usuario_id = updates.usuario_id\n),\nbuscar_xp AS (\n  SELECT\n    alvos.id,\n    alvos.usuario_id,\n    alvos.status_atual,\n    alvos.catalogo_id,\n    alvos.quest_estagio,\n    alvos.concluido_em_anterior,\n    alvos.recorrencias,\n    alvos.novo_status,\n    alvos.xp_extra,\n    alvos.data_referencia,\n    alvos.config,\n    COALESCE(qc.xp, 10) AS xp_base_quest\n  FROM alvos\n  LEFT JOIN public.quests_catalogo qc ON qc.id = alvos.catalogo_id\n),\nalvos_enriquecidos AS (\n  SELECT\n    buscar_xp.*,\n    COALESCE(buscar_xp.config->>'recorrencia', 'unica') AS recorrencia,\n    CASE WHEN buscar_xp.novo_status = 'concluida' THEN buscar_xp.xp_base_quest ELSE 0 END AS xp_base_evento,\n    0 AS xp_bonus_evento,\n    (\n      SELECT dia_elem->>'data'\n      FROM jsonb_array_elements(buscar_xp.recorrencias->'dias') AS dia_elem\n      WHERE (dia_elem->>'data')::date = buscar_xp.data_referencia\n      LIMIT 1\n    ) AS data_planejada,\n    (\n      SELECT COUNT(*) FROM jsonb_array_elements(buscar_xp.recorrencias->'dias') AS dia_elem\n    ) AS total_planejadas,\n    (\n      SELECT COALESCE((ch.detalhes->>'total_concluidas')::int, 0)\n      FROM public.conquistas_historico ch\n      WHERE ch.usuario_id = buscar_xp.usuario_id\n        AND ch.usuarios_quest_id = buscar_xp.id\n        AND ch.tipo = 'quest'\n      LIMIT 1\n    ) AS total_concluidas_anterior\n  FROM buscar_xp\n),\natualizados AS (\n  UPDATE public.usuarios_quest uq\n  SET\n    status = CASE\n      WHEN ae.novo_status IN ('pendente','ativa','concluida','vencida','cancelada') THEN ae.novo_status\n      ELSE uq.status\n    END,\n    atualizado_em = NOW(),\n    concluido_em = CASE\n      WHEN ae.novo_status = 'concluida' AND uq.concluido_em IS NULL THEN NOW()\n      ELSE uq.concluido_em\n    END,\n    quest_estagio = CASE\n      WHEN ae.novo_status = 'concluida' AND (ae.total_concluidas_anterior + 1) >= COALESCE(ae.total_planejadas, 1) THEN 'feito'\n      WHEN uq.quest_estagio = 'a_fazer' AND uq.recorrencias IS NOT NULL THEN 'fazendo'\n      ELSE COALESCE(uq.quest_estagio, 'a_fazer')\n    END\n  FROM alvos_enriquecidos ae\n  WHERE uq.id = ae.id\n  RETURNING uq.id, ae.usuario_id, ae.novo_status, ae.recorrencia, ae.xp_base_evento, ae.xp_bonus_evento, ae.xp_extra, ae.config, ae.data_referencia, ae.data_planejada, COALESCE(ae.config->>'titulo', 'Quest Personalizada') AS quest_titulo\n),\nhistorico_atualizado AS (\n  UPDATE public.conquistas_historico ch\n  SET\n    usuarios_quest_id = upd.id,\n    xp_base = ch.xp_base + upd.xp_base_evento,\n    xp_bonus = ch.xp_bonus + (upd.xp_bonus_evento + upd.xp_extra),\n    detalhes = jsonb_set(\n      jsonb_set(\n        jsonb_set(\n          COALESCE(ch.detalhes, '{}'::jsonb),\n          '{data_conclusao}',\n          to_jsonb(upd.data_referencia::text)\n        ),\n        '{total_concluidas}',\n        to_jsonb((COALESCE((ch.detalhes->>'total_concluidas')::int, 0) + 1))\n      ),\n      '{ocorrencias}',\n      (\n        COALESCE(ch.detalhes->'ocorrencias', '[]'::jsonb) || \n        jsonb_build_array(\n          jsonb_build_object(\n            'data_planejada', COALESCE(upd.data_planejada, upd.data_referencia::text),\n            'data_concluida', upd.data_referencia::text,\n            'data_registrada', NOW()::text,\n            'xp_base', upd.xp_base_evento,\n            'xp_bonus', upd.xp_bonus_evento + upd.xp_extra\n          )\n        )\n      )\n    ),\n    registrado_em = NOW()\n  FROM atualizados upd\n  WHERE ch.usuario_id = upd.usuario_id\n    AND (ch.usuarios_quest_id = upd.id OR ch.meta_codigo = upd.id::text)\n    AND ch.tipo = 'quest'\n    AND upd.novo_status = 'concluida'\n  RETURNING ch.id, upd.id AS quest_id\n),\nhistorico_inserido AS (\n  INSERT INTO public.conquistas_historico (\n    usuario_id,\n    usuarios_quest_id,\n    tipo,\n    meta_codigo,\n    meta_titulo,\n    xp_base,\n    xp_bonus,\n    registrado_em,\n    detalhes\n  )\n  SELECT\n    upd.usuario_id,\n    upd.id,\n    'quest',\n    upd.id::text,\n    upd.quest_titulo,\n    upd.xp_base_evento,\n    upd.xp_bonus_evento + upd.xp_extra,\n    NOW(),\n    jsonb_build_object(\n      'recorrencia', upd.recorrencia,\n      'data_conclusao', upd.data_referencia::text,\n      'total_concluidas', 1,\n      'ocorrencias', jsonb_build_array(\n        jsonb_build_object(\n          'data_planejada', COALESCE(upd.data_planejada, upd.data_referencia::text),\n          'data_concluida', upd.data_referencia::text,\n          'data_registrada', NOW()::text,\n          'xp_base', upd.xp_base_evento,\n          'xp_bonus', upd.xp_bonus_evento + upd.xp_extra\n        )\n      )\n    )\n  FROM atualizados upd\n  WHERE upd.novo_status = 'concluida'\n    AND NOT EXISTS (\n      SELECT 1 FROM historico_atualizado hau WHERE hau.quest_id = upd.id\n    )\n  RETURNING id\n),\nxp_totais AS (\n  SELECT\n    COALESCE(SUM(upd.xp_base_evento), 0) AS xp_base_total,\n    COALESCE(SUM(upd.xp_bonus_evento + upd.xp_extra), 0) AS xp_bonus_total,\n    COUNT(*) FILTER (WHERE upd.novo_status = 'concluida') AS concluidas\n  FROM atualizados upd\n),\natualiza_estado AS (\n  UPDATE public.usuarios_conquistas rj\n  SET\n    xp_total = rj.xp_total + ((SELECT xp_base_total FROM xp_totais) + (SELECT xp_bonus_total FROM xp_totais)),\n    xp_base = COALESCE(rj.xp_base, 0) + (SELECT xp_base_total FROM xp_totais),\n    xp_bonus = COALESCE(rj.xp_bonus, 0) + (SELECT xp_bonus_total FROM xp_totais),\n    total_quests_concluidas = rj.total_quests_concluidas + (SELECT concluidas FROM xp_totais),\n    total_xp_hoje = (SELECT xp_base_total FROM xp_totais) + (SELECT xp_bonus_total FROM xp_totais),\n    atualizado_em = NOW()\n  WHERE rj.usuario_id = (SELECT usuario_id FROM payload LIMIT 1)\n  RETURNING rj.usuario_id\n)\nSELECT\n  payload.usuario_id,\n  payload.novas_quests,\n  payload.atualizacoes,\n  payload.estado_inicial,\n  ((SELECT xp_base_total FROM xp_totais) + (SELECT xp_bonus_total FROM xp_totais)) AS xp_ganho,\n  (SELECT xp_base_total FROM xp_totais) AS xp_base_total,\n  (SELECT xp_bonus_total FROM xp_totais) AS xp_bonus_total,\n  (SELECT concluidas FROM xp_totais) AS quests_concluidas,\n  0 AS reinicios\nFROM payload;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id, JSON.stringify($json.atualizacoes || []), JSON.stringify($json.estado_inicial || {}), JSON.stringify($json.novas_quests || []) ] }}"
        }
      },
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      },
      "id": "83ba4efa-c2a7-4116-a448-f95ae2e5d522",
      "name": "Aplicar Atualizacoes",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1984,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT $1::uuid AS usuario_id\n),\nestado AS (\n  SELECT\n    eu.usuario_id,\n    eu.xp_total,\n    (SELECT j.nivel FROM public.jornada_niveis j WHERE eu.xp_total >= j.xp_minimo ORDER BY j.nivel DESC LIMIT 1) AS nivel_atual,\n    (SELECT j.nome FROM public.jornada_niveis j WHERE eu.xp_total >= j.xp_minimo ORDER BY j.nivel DESC LIMIT 1) AS titulo_nivel,\n    (SELECT j.xp_proximo_nivel FROM public.jornada_niveis j WHERE eu.xp_total >= j.xp_minimo ORDER BY j.nivel DESC LIMIT 1) AS xp_proximo_nivel\n  FROM public.usuarios_conquistas eu\n  JOIN payload ON payload.usuario_id = eu.usuario_id\n),\nupdated AS (\n  UPDATE public.usuarios_conquistas eu\n  SET\n    nivel_atual = estado.nivel_atual,\n    titulo_nivel = estado.titulo_nivel,\n    xp_proximo_nivel = estado.xp_proximo_nivel,\n    atualizado_em = NOW()\n  FROM estado\n  WHERE eu.usuario_id = estado.usuario_id\n  RETURNING eu.usuario_id, eu.xp_total, eu.nivel_atual, eu.titulo_nivel, eu.xp_proximo_nivel\n),\nresultado AS (\n  SELECT * FROM updated\n  UNION ALL\n  SELECT estado.usuario_id, estado.xp_total, estado.nivel_atual, estado.titulo_nivel, estado.xp_proximo_nivel\n  FROM estado\n  WHERE NOT EXISTS (SELECT 1 FROM updated)\n)\nSELECT\n  resultado.usuario_id,\n  resultado.xp_total,\n  resultado.nivel_atual,\n  resultado.titulo_nivel,\n  resultado.xp_proximo_nivel,\n  $2::numeric AS xp_ganho,\n  $3::integer AS quests_concluidas,\n  $4::integer AS reinicios,\n  $5::jsonb AS novas_quests,\n  $6::jsonb AS atualizacoes,\n  $7::jsonb AS estado_inicial\nFROM resultado;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id, $json.xp_ganho, $json.quests_concluidas, $json.reinicios, JSON.stringify($json.novas_quests || []), JSON.stringify($json.atualizacoes || []), JSON.stringify($json.estado_inicial || {}) ] }}"
        }
      },
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      },
      "id": "f499e8ad-4c9a-4203-8252-d77eddc07e14",
      "name": "Atualizar Estado",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2208,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH personalizadas AS (\n  SELECT\n    uq.id,\n    uq.status,\n    uq.catalogo_id,\n    uq.quest_estagio,\n    uq.concluido_em,\n    uq.ativado_em,\n    uq.atualizado_em,\n    COALESCE(uq.config, '{}'::jsonb) AS config\n  FROM public.usuarios_quest uq\n  WHERE uq.usuario_id = $1::uuid\n)\nSELECT\n  rj.usuario_id,\n  rj.xp_total,\n  rj.nivel_atual,\n  rj.titulo_nivel,\n  rj.xp_proximo_nivel,\n  rj.sequencia_atual,\n  rj.sequencia_recorde,\n  rj.meta_sequencia_codigo,\n  rj.proxima_meta_codigo,\n  rj.sequencia_status,\n  COALESCE(jsonb_agg(personalizadas) FILTER (WHERE personalizadas.id IS NOT NULL), '[]'::jsonb) AS quests_personalizadas\nFROM public.usuarios_conquistas rj\nLEFT JOIN personalizadas ON TRUE\nWHERE rj.usuario_id = $1::uuid\nGROUP BY\n  rj.usuario_id,\n  rj.xp_total,\n  rj.nivel_atual,\n  rj.titulo_nivel,\n  rj.xp_proximo_nivel,\n  rj.sequencia_atual,\n  rj.sequencia_recorde,\n  rj.meta_sequencia_codigo,\n  rj.proxima_meta_codigo,\n  rj.sequencia_status;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id ] }}"
        }
      },
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      },
      "id": "bf3cbc9d-2938-44a0-bd99-1739100110d6",
      "name": "Buscar Snapshot Final",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2640,
        272
      ]
    },
    {
      "parameters": {
        "jsCode": "const estadoItems = $items(\"Atualizar Estado\", 0, 0) || [];\nconst estadoAtualizado = (estadoItems[0] && estadoItems[0].json) || {};\nconst snapshotFinal = $input.item.json || {};\n\nconst parseList = (value) => {\n  if (!value) return [];\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') {\n    try {\n      const parsed = JSON.parse(value);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch (error) {\n      return [];\n    }\n  }\n  return [];\n};\n\nconst toNumber = (value, fallback = 0) => {\n  const numeric = Number(value);\n  return Number.isFinite(numeric) ? numeric : fallback;\n};\n\nconst filaItems = $items(\"Preparar Operacoes\", 0, 0) || [];\nconst filaEspera = parseList(filaItems[0]?.json?.fila_espera);\n\nreturn [{\n  json: {\n    usuario_id: estadoAtualizado.usuario_id ?? snapshotFinal.usuario_id ?? null,\n    xp_total: toNumber(estadoAtualizado.xp_total ?? snapshotFinal.xp_total ?? 0),\n    nivel_atual: estadoAtualizado.nivel_atual ?? snapshotFinal.nivel_atual ?? null,\n    titulo_nivel: estadoAtualizado.titulo_nivel ?? snapshotFinal.titulo_nivel ?? null,\n    xp_proximo_nivel: toNumber(estadoAtualizado.xp_proximo_nivel ?? snapshotFinal.xp_proximo_nivel ?? 0),\n    xp_ganho: toNumber(estadoAtualizado.xp_ganho, 0),\n    quests_concluidas_no_evento: toNumber(estadoAtualizado.quests_concluidas, 0),\n    reinicios_registrados: toNumber(estadoAtualizado.reinicios, 0),\n    novas_quests_registradas: parseList(estadoAtualizado.novas_quests),\n    atualizacoes_processadas: parseList(estadoAtualizado.atualizacoes),\n    fila_espera: filaEspera,\n    snapshot_final: snapshotFinal\n  }\n}];"
      },
      "id": "176a27c5-308c-44b2-826e-094b395f1215",
      "name": "Montar Resposta",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2864,
        272
      ]
    }
  ],
  "connections": {
    "start": {
      "main": [
        [
          {
            "node": "Normalizar Entrada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalizar Entrada": {
      "main": [
        [
          {
            "node": "Buscar Estado e Quests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Estado e Quests": {
      "main": [
        [
          {
            "node": "Preparar Operacoes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Inserir Instancias": {
      "main": [
        [
          {
            "node": "Aplicar Atualizacoes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aplicar Atualizacoes": {
      "main": [
        [
          {
            "node": "Atualizar Estado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Atualizar Estado": {
      "main": [
        [
          {
            "node": "Atualizar Jornada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Atualizar Jornada": {
      "main": [
        [
          {
            "node": "Buscar Snapshot Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Snapshot Final": {
      "main": [
        [
          {
            "node": "Montar Resposta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Operacoes": {
      "main": [
        [
          {
            "node": "Verificar e Criar Quest Inicial",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verificar e Criar Quest Inicial": {
      "main": [
        [
          {
            "node": "Inserir Instancias",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {
    "start": [
      {
        "json": {
          "usuario_id": "d949d81c-9235-41ce-8b3b-6b5d593c5e24",
          "quests_personalizadas": "[{\"titulo\":\"Prática diária de respiração consciente para foco\",\"descricao\":\"Executar exercícios de respiração consciente todos os dias para reduzir ansiedade e manter o foco presente durante o trabalho.\",\"contexto_origem\":\"gestão da ansiedade e foco na mente agitada\",\"prioridade\":\"alta\",\"recorrencia\":\"diaria\",\"prazo_inicio\":\"2025-11-24\",\"prazo_fim\":\"2025-11-30\",\"progresso_meta\":7,\"status_inicial\":\"pendente\",\"area_vida_id\":\"11111111-1111-4111-8111-111111111111\",\"sabotador_id\":null,\"insight_id\":\"8427c12a-0414-4c5e-a6be-b6f65598d97d\",\"complexidade\":2,\"payload_extra\":{\"canal\":\"app\"}},{\"titulo\":\"Dividir metas do app em etapas diárias realistas\",\"descricao\":\"Fracionar as grandes metas do desenvolvimento do app em pequenas tarefas diárias para reduzir a pressão do prazo e celebrar cada avanço.\",\"contexto_origem\":\"controle do perfeccionismo e pressão interna para cumprir prazos\",\"prioridade\":\"alta\",\"recorrencia\":\"diaria\",\"prazo_inicio\":\"2025-11-24\",\"prazo_fim\":\"2025-11-30\",\"progresso_meta\":7,\"status_inicial\":\"pendente\",\"area_vida_id\":\"22222222-2222-4222-8222-222222222222\",\"sabotador_id\":null,\"insight_id\":\"8427c12a-0414-4c5e-a6be-b6f65598d97d\",\"complexidade\":3,\"payload_extra\":{\"canal\":\"app\"}},{\"titulo\":\"Pausas conscientes com técnica Pomodoro\",\"descricao\":\"Implementar pausas regulares usando a técnica Pomodoro para evitar sobrecarga mental e manter energia durante o desenvolvimento do app.\",\"contexto_origem\":\"risco de sobrecarga mental por longas horas de trabalho sem pausas\",\"prioridade\":\"alta\",\"recorrencia\":\"diaria\",\"prazo_inicio\":\"2025-11-24\",\"prazo_fim\":\"2025-11-30\",\"progresso_meta\":7,\"status_inicial\":\"pendente\",\"area_vida_id\":\"22222222-2222-4222-8222-222222222222\",\"sabotador_id\":null,\"insight_id\":\"8029200f-c852-46cc-a926-e95123940707\",\"complexidade\":3,\"payload_extra\":{\"canal\":\"app\"}}]",
          "atualizacoes_status": "[]"
        }
      }
    ]
  },
  "versionId": "9456e343-8bdf-485a-98df-6da61ba99204",
  "triggerCount": 0,
  "shared": [
    {
      "createdAt": "2025-11-07T16:03:52.061Z",
      "role": "workflow:owner",
      "workflowId": "bTeLj5qOKQo9PDMO",
      "projectId": "u1M57XAwIiLpPwjp",
      "project": {
        "createdAt": "2025-09-16T16:13:20.606Z",
        "id": "u1M57XAwIiLpPwjp",
        "name": "Aldo Santos <lindualdo@hotmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "createdAt": "2025-09-16T16:13:20.606Z",
            "userId": "fa864d51-475e-4765-b3b4-12788525a3e6",
            "projectId": "u1M57XAwIiLpPwjp",
            "user": {
              "createdAt": "2025-09-16T16:13:20.056Z",
              "id": "fa864d51-475e-4765-b3b4-12788525a3e6",
              "email": "lindualdo@hotmail.com",
              "firstName": "Aldo",
              "lastName": "Santos",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-09-16T16:22:10.583Z",
                "personalization_survey_n8n_version": "1.108.1"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "jUAvu7DUAzyqZhJd",
                "userActivatedAt": 1758041156747,
                "easyAIWorkflowOnboarded": true,
                "dismissedCallouts": {
                  "preBuiltAgentsModalCallout": true
                },
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1759918723295
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": []
}
