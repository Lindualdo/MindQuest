{
  "createdAt": "2025-11-07T16:03:52.061Z",
  "id": "bTeLj5qOKQo9PDMO",
  "name": "sw_xp_quest",
  "description": null,
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "usuario_id"
            },
            {
              "name": "quests_personalizadas"
            },
            {
              "name": "atualizacoes_status"
            }
          ]
        }
      },
      "id": "8b03c451-22b0-46d3-8e08-f3515d6937d0",
      "name": "start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        800,
        -64
      ]
    },
    {
      "parameters": {
        "jsCode": "const item = $input.item.json || {};\n\nconst parseList = (value) => {\n  if (!value) return [];\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') {\n    try {\n      const parsed = JSON.parse(value);\n      if (Array.isArray(parsed)) return parsed;\n    } catch (error) {}\n  }\n  return [];\n};\n\nconst usuarioId = item.usuario_id;\nif (!usuarioId) {\n  throw new Error('usuario_id obrigatório');\n}\n\nconst quests = parseList(item.quests_personalizadas);\nconst updates = parseList(item.atualizacoes_status);\n\nreturn [{\n  json: {\n    usuario_id: usuarioId,\n    novas_quests: quests,\n    atualizacoes: updates\n  }\n}];"
      },
      "id": "1c6baeea-a3c1-4dc2-8726-35827f05a378",
      "name": "Normalizar Entrada",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        -64
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "71Ru87yaRA5SNjOQ",
          "mode": "list",
          "cachedResultUrl": "/workflow/71Ru87yaRA5SNjOQ",
          "cachedResultName": "sw_calcula_jornada"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "usuario_id": "={{ $('start').first().json.usuario_id }}"
          },
          "matchingColumns": [
            "usuario_id"
          ],
          "schema": [
            {
              "id": "usuario_id",
              "displayName": "usuario_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "1566eebb-d586-427d-97d3-01c5539b8321",
      "name": "Atualizar Jornada",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        2640,
        -64
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH quests AS (\n  SELECT\n    uq.id,\n    uq.status,\n    uq.ativado_em,\n    uq.atualizado_em,\n    uq.catalogo_id,\n    COALESCE(uq.config, '{}'::jsonb) AS config\n  FROM public.usuarios_quest uq\n  WHERE uq.usuario_id = $1::uuid\n)\nSELECT\n  u.usuario_id,\n  u.nivel_atual,\n  u.titulo_nivel,\n  u.xp_total,\n  u.total_quests_concluidas,\n  u.total_quests_personalizadas,\n  u.sequencia_status,\n  COALESCE(jsonb_agg(quests) FILTER (WHERE quests.id IS NOT NULL), '[]'::jsonb) AS quests_ativas\nFROM public.usuarios_conquistas u\nLEFT JOIN quests ON TRUE\nWHERE u.usuario_id = $1::uuid\nGROUP BY\n  u.usuario_id,\n  u.nivel_atual,\n  u.titulo_nivel,\n  u.xp_total,\n  u.total_quests_concluidas,\n  u.total_quests_personalizadas,\n  u.sequencia_status;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id ] }}"
        }
      },
      "id": "e3754a8f-d6f9-41fe-b27b-629d46781d45",
      "name": "Buscar Estado e Quests",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1280,
        -64
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const entradaLista = $items(\"Normalizar Entrada\") || [];\nconst entrada = (entradaLista[0] && entradaLista[0].json) || {};\nconst estado = $input.item.json || {};\n\nreturn [{\n  json: {\n    usuario_id: entrada.usuario_id,\n    novas_quests: Array.isArray(entrada.novas_quests) ? entrada.novas_quests : [],\n    atualizacoes: Array.isArray(entrada.atualizacoes) ? entrada.atualizacoes : [],\n    estado_inicial: estado\n  }\n}];"
      },
      "id": "5ca16b20-f983-4f21-b36a-88056e1b0074",
      "name": "Preparar Operacoes",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1504,
        -64
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT $1::uuid AS usuario_id,\n  $2::jsonb AS novas_quests,\n  $3::jsonb AS atualizacoes,\n  $4::jsonb AS estado_inicial\n),\nverificar_quests AS (\n  SELECT COUNT(*) AS total_quests\n  FROM public.usuarios_quest uq\n  WHERE uq.usuario_id = (SELECT usuario_id FROM payload)\n    AND uq.status IN ('disponivel', 'ativa')\n),\nbuscar_reflexao_diaria AS (\n  SELECT id\n  FROM public.quests_catalogo\n  WHERE codigo = 'reflexao_diaria'\n  LIMIT 1\n),\ncriar_quest_inicial AS (\n  INSERT INTO public.usuarios_quest (\n    id,\n    usuario_id,\n    catalogo_id,\n    status,\n    ativado_em,\n    config\n  )\n  SELECT\n    gen_random_uuid(),\n    (SELECT usuario_id FROM payload),\n    brd.id,\n    'ativa',\n    NOW(),\n    jsonb_build_object(\n      'titulo', 'Reflexão Diária',\n      'descricao', 'Conversa com seu Assistente de reflexão',\n      'prioridade', 'alta',\n      'recorrencia', 'diaria',\n      'conversa', true,\n      'contexto_origem', 'sistema'\n    )\n  FROM buscar_reflexao_diaria brd\n  CROSS JOIN verificar_quests vq\n  WHERE vq.total_quests = 0\n  RETURNING id\n)\nSELECT\n  (SELECT usuario_id FROM payload) AS usuario_id,\n  payload.novas_quests,\n  payload.atualizacoes,\n  payload.estado_inicial,\n  COALESCE((SELECT COUNT(*) FROM criar_quest_inicial), 0) AS quest_inicial_criada\nFROM payload;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id, JSON.stringify($json.novas_quests || []), JSON.stringify($json.atualizacoes || []), JSON.stringify($json.estado_inicial || {}) ] }}"
        }
      },
      "id": "ee63f3b0-11d7-43c2-972f-acd745c4d809",
      "name": "Verificar e Criar Quest Inicial",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1744,
        -64
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT\n    $1::uuid AS usuario_id,\n    $2::jsonb AS novas_quests,\n    $3::jsonb AS atualizacoes,\n    $4::jsonb AS estado_inicial\n),\ncriar_conquistas_se_nao_existe AS (\n  INSERT INTO public.usuarios_conquistas (usuario_id, xp_total, nivel_atual, titulo_nivel, xp_proximo_nivel, total_quests_concluidas, total_quests_personalizadas, atualizado_em)\n  SELECT\n    payload.usuario_id,\n    0,\n    1,\n    (SELECT nome FROM public.jornada_niveis WHERE nivel = 1 LIMIT 1),\n    (SELECT xp_proximo_nivel FROM public.jornada_niveis WHERE nivel = 1 LIMIT 1),\n    0,\n    0,\n    NOW()\n  FROM payload\n  WHERE NOT EXISTS (\n    SELECT 1 FROM public.usuarios_conquistas uc WHERE uc.usuario_id = payload.usuario_id\n  )\n  ON CONFLICT (usuario_id) DO NOTHING\n  RETURNING usuario_id\n),\nbuscar_quest_custom AS (\n  SELECT id FROM public.quests_catalogo WHERE codigo = 'quest_custom' LIMIT 1\n),\nrows AS (\n  SELECT\n    payload.usuario_id,\n    rec->>'titulo' AS titulo,\n    rec->>'descricao' AS descricao,\n    rec->>'contexto_origem' AS contexto_origem,\n    COALESCE(rec->>'prioridade', 'media') AS prioridade,\n    COALESCE(rec->>'recorrencia', 'unica') AS recorrencia,\n    rec->>'prazo_inicio' AS prazo_inicio,\n    rec->>'prazo_fim' AS prazo_fim,\n    COALESCE(rec->>'status_inicial', 'disponivel') AS status_inicial,\n    COALESCE(rec->'payload_extra', '{}'::jsonb) AS payload_extra,\n    COALESCE((rec->>'xp_recompensa')::int, 10) AS xp_recompensa,\n    COALESCE(\n      NULLIF((rec->>'catalogo_id')::uuid, NULL),\n      (SELECT id FROM buscar_quest_custom)\n    ) AS catalogo_id,\n    NULLIF((rec->>'area_vida_id')::uuid, NULL) AS area_vida_id,\n    NULLIF(rec->>'sabotador_id', '') AS sabotador_id,\n    NULLIF((rec->>'insight_id')::uuid, NULL) AS insight_id,\n    NULLIF((rec->>'objetivo_id')::uuid, NULL) AS objetivo_id,\n    COALESCE(rec->'objetivos_secundarios', '[]'::jsonb) AS objetivos_secundarios,\n    COALESCE(rec->'base_cientifica', '{}'::jsonb) AS base_cientifica\n  FROM payload,\n       jsonb_array_elements(payload.novas_quests) rec\n),\ninserted AS (\n  INSERT INTO public.usuarios_quest (\n    id,\n    usuario_id,\n    catalogo_id,\n    status,\n    ativado_em,\n    config,\n    area_vida_id,\n    sabotador_id,\n    insight_id,\n    objetivo_id\n  )\n  SELECT\n    gen_random_uuid(),\n    rq.usuario_id,\n    COALESCE(rq.catalogo_id, (SELECT id FROM buscar_quest_custom)),\n    rq.status_inicial,\n    NOW(),\n    jsonb_build_object(\n      'titulo', rq.titulo,\n      'descricao', rq.descricao,\n      'prioridade', rq.prioridade,\n      'recorrencia', rq.recorrencia,\n      'contexto_origem', rq.contexto_origem,\n      'payload_extra', rq.payload_extra,\n      'prazo_inicio', rq.prazo_inicio,\n      'prazo_fim', rq.prazo_fim,\n      'base_cientifica', rq.base_cientifica\n    ),\n    rq.area_vida_id,\n    rq.sabotador_id,\n    rq.insight_id,\n    rq.objetivo_id\n  FROM rows rq\n  WHERE COALESCE(rq.catalogo_id, (SELECT id FROM buscar_quest_custom)) IS NOT NULL\n  RETURNING id, objetivo_id\n),\ninsert_objetivo_principal AS (\n  INSERT INTO public.quest_objetivos (usuarios_quest_id, objetivo_id, tipo_impacto)\n  SELECT ins.id, ins.objetivo_id, 'direto'\n  FROM inserted ins\n  WHERE ins.objetivo_id IS NOT NULL\n  ON CONFLICT (usuarios_quest_id, objetivo_id) DO NOTHING\n  RETURNING id\n),\nrows_com_id AS (\n  SELECT rq.*, ins.id AS quest_id\n  FROM rows rq\n  JOIN inserted ins ON TRUE\n  WHERE rq.objetivo_id = ins.objetivo_id OR (rq.objetivo_id IS NULL AND ins.objetivo_id IS NULL)\n),\ninsert_objetivos_secundarios AS (\n  INSERT INTO public.quest_objetivos (usuarios_quest_id, objetivo_id, tipo_impacto)\n  SELECT \n    rci.quest_id,\n    (obj_sec->>'objetivo_id')::uuid,\n    'indireto'\n  FROM rows_com_id rci,\n       jsonb_array_elements(rci.objetivos_secundarios) obj_sec\n  WHERE (obj_sec->>'objetivo_id') IS NOT NULL\n  ON CONFLICT (usuarios_quest_id, objetivo_id) DO NOTHING\n  RETURNING id\n),\natualiza_estado AS (\n  UPDATE public.usuarios_conquistas\n  SET\n    total_quests_personalizadas = total_quests_personalizadas + (SELECT COUNT(*) FROM inserted),\n    atualizado_em = NOW()\n  WHERE usuario_id = (SELECT usuario_id FROM payload)\n  RETURNING total_quests_personalizadas\n)\nSELECT\n  payload.usuario_id,\n  payload.novas_quests,\n  payload.atualizacoes,\n  payload.estado_inicial,\n  COALESCE((SELECT COUNT(*) FROM inserted), 0) AS novas_inseridas\nFROM payload;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id, JSON.stringify($json.novas_quests || []), JSON.stringify($json.atualizacoes || []), JSON.stringify($json.estado_inicial || {}) ] }}"
        }
      },
      "id": "3c05d9a8-ff1f-493f-9e0c-1112e2a93f99",
      "name": "Inserir Instancias",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1984,
        -64
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT\n    $1::uuid AS usuario_id,\n    $2::jsonb AS atualizacoes,\n    $3::jsonb AS estado_inicial,\n    $4::jsonb AS novas_quests\n),\nupdates AS (\n  SELECT\n    payload.usuario_id,\n    (rec->>'instancia_id')::uuid AS instancia_id,\n    COALESCE(rec->>'novo_status', 'disponivel') AS novo_status,\n    COALESCE((rec->>'xp_extra')::int, 0) AS xp_extra,\n    COALESCE((rec->>'data_referencia')::date, CURRENT_DATE) AS data_referencia\n  FROM payload,\n       jsonb_array_elements(payload.atualizacoes) rec\n  WHERE rec ? 'instancia_id'\n),\nalvos AS (\n  SELECT\n    uq.id,\n    uq.usuario_id,\n    uq.status AS status_atual,\n    uq.catalogo_id,\n    updates.novo_status,\n    updates.xp_extra,\n    updates.data_referencia,\n    COALESCE(uq.config, '{}'::jsonb) AS config\n  FROM updates\n  JOIN public.usuarios_quest uq ON uq.id = updates.instancia_id\n  WHERE uq.usuario_id = updates.usuario_id\n),\nbuscar_xp AS (\n  SELECT\n    alvos.id,\n    alvos.usuario_id,\n    alvos.status_atual,\n    alvos.catalogo_id,\n    alvos.novo_status,\n    alvos.xp_extra,\n    alvos.data_referencia,\n    alvos.config,\n    COALESCE(qc.xp, 10) AS xp_base_quest\n  FROM alvos\n  LEFT JOIN public.quests_catalogo qc ON qc.id = alvos.catalogo_id\n),\nalvos_enriquecidos AS (\n  SELECT\n    buscar_xp.*,\n    COALESCE(buscar_xp.config->>'recorrencia', 'unica') AS recorrencia,\n    CASE WHEN buscar_xp.novo_status = 'concluida' THEN buscar_xp.xp_base_quest ELSE 0 END AS xp_base_evento,\n    0 AS xp_bonus_evento,\n    buscar_xp.data_referencia AS data_planejada,\n    (\n      SELECT COUNT(*) FROM public.quests_recorrencias qr\n      WHERE qr.usuarios_quest_id = buscar_xp.id\n    ) AS total_planejadas,\n    (\n      SELECT COUNT(*) FROM public.quests_recorrencias qr\n      WHERE qr.usuarios_quest_id = buscar_xp.id\n        AND qr.status = 'concluida'\n    ) AS total_concluidas_anterior\n  FROM buscar_xp\n),\natualizados AS (\n  UPDATE public.usuarios_quest uq\n  SET\n    status = CASE\n      WHEN ae.novo_status IN ('disponivel','ativa','inativa') THEN ae.novo_status\n      WHEN ae.novo_status = 'concluida' AND (ae.total_concluidas_anterior + 1) >= COALESCE(ae.total_planejadas, 1) THEN 'inativa'\n      ELSE uq.status\n    END,\n    atualizado_em = NOW()\n  FROM alvos_enriquecidos ae\n  WHERE uq.id = ae.id\n  RETURNING uq.id, ae.usuario_id, ae.novo_status, ae.recorrencia, ae.xp_base_evento, ae.xp_bonus_evento, ae.xp_extra, ae.config, ae.data_referencia, ae.data_planejada, COALESCE(ae.config->>'titulo', 'Quest Personalizada') AS quest_titulo\n),\nrecorrencia_atualizada AS (\n  UPDATE public.quests_recorrencias qr\n  SET\n    data_concluida = upd.data_referencia,\n    status = 'concluida',\n    xp_base = upd.xp_base_evento,\n    xp_bonus = upd.xp_bonus_evento + upd.xp_extra,\n    atualizado_em = NOW()\n  FROM atualizados upd\n  WHERE qr.usuarios_quest_id = upd.id\n    AND qr.data_planejada = upd.data_referencia\n    AND upd.novo_status = 'concluida'\n  RETURNING qr.id, upd.id AS quest_id\n),\nrecorrencia_inserida AS (\n  INSERT INTO public.quests_recorrencias (\n    usuarios_quest_id,\n    data_planejada,\n    data_concluida,\n    status,\n    xp_base,\n    xp_bonus\n  )\n  SELECT\n    upd.id,\n    upd.data_referencia,\n    upd.data_referencia,\n    'concluida',\n    upd.xp_base_evento,\n    upd.xp_bonus_evento + upd.xp_extra\n  FROM atualizados upd\n  WHERE upd.novo_status = 'concluida'\n    AND NOT EXISTS (\n      SELECT 1 FROM recorrencia_atualizada rau WHERE rau.quest_id = upd.id\n    )\n  RETURNING id\n),\nxp_totais AS (\n  SELECT\n    COALESCE(SUM(upd.xp_base_evento), 0) AS xp_base_total,\n    COALESCE(SUM(upd.xp_bonus_evento + upd.xp_extra), 0) AS xp_bonus_total,\n    COUNT(*) FILTER (WHERE upd.novo_status = 'concluida') AS concluidas\n  FROM atualizados upd\n),\natualiza_estado AS (\n  UPDATE public.usuarios_conquistas rj\n  SET\n    xp_total = rj.xp_total + ((SELECT xp_base_total FROM xp_totais) + (SELECT xp_bonus_total FROM xp_totais)),\n    xp_base = COALESCE(rj.xp_base, 0) + (SELECT xp_base_total FROM xp_totais),\n    xp_bonus = COALESCE(rj.xp_bonus, 0) + (SELECT xp_bonus_total FROM xp_totais),\n    total_quests_concluidas = rj.total_quests_concluidas + (SELECT concluidas FROM xp_totais),\n    total_xp_hoje = (SELECT xp_base_total FROM xp_totais) + (SELECT xp_bonus_total FROM xp_totais),\n    atualizado_em = NOW()\n  WHERE rj.usuario_id = (SELECT usuario_id FROM payload LIMIT 1)\n  RETURNING rj.usuario_id\n)\nSELECT\n  payload.usuario_id,\n  payload.novas_quests,\n  payload.atualizacoes,\n  payload.estado_inicial,\n  ((SELECT xp_base_total FROM xp_totais) + (SELECT xp_bonus_total FROM xp_totais)) AS xp_ganho,\n  (SELECT xp_base_total FROM xp_totais) AS xp_base_total,\n  (SELECT xp_bonus_total FROM xp_totais) AS xp_bonus_total,\n  (SELECT concluidas FROM xp_totais) AS quests_concluidas,\n  0 AS reinicios\nFROM payload;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id, JSON.stringify($json.atualizacoes || []), JSON.stringify($json.estado_inicial || {}), JSON.stringify($json.novas_quests || []) ] }}"
        }
      },
      "id": "4f4a17d9-8135-4879-942c-33f9e76bc4dd",
      "name": "Aplicar Atualizacoes",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2192,
        -64
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT $1::uuid AS usuario_id\n),\nestado AS (\n  SELECT\n    eu.usuario_id,\n    eu.xp_total,\n    (SELECT j.nivel FROM public.jornada_niveis j WHERE eu.xp_total >= j.xp_minimo ORDER BY j.nivel DESC LIMIT 1) AS nivel_atual,\n    (SELECT j.nome FROM public.jornada_niveis j WHERE eu.xp_total >= j.xp_minimo ORDER BY j.nivel DESC LIMIT 1) AS titulo_nivel,\n    (SELECT j.xp_proximo_nivel FROM public.jornada_niveis j WHERE eu.xp_total >= j.xp_minimo ORDER BY j.nivel DESC LIMIT 1) AS xp_proximo_nivel\n  FROM public.usuarios_conquistas eu\n  JOIN payload ON payload.usuario_id = eu.usuario_id\n),\nupdated AS (\n  UPDATE public.usuarios_conquistas eu\n  SET\n    nivel_atual = estado.nivel_atual,\n    titulo_nivel = estado.titulo_nivel,\n    xp_proximo_nivel = estado.xp_proximo_nivel,\n    atualizado_em = NOW()\n  FROM estado\n  WHERE eu.usuario_id = estado.usuario_id\n  RETURNING eu.usuario_id, eu.xp_total, eu.nivel_atual, eu.titulo_nivel, eu.xp_proximo_nivel\n),\nresultado AS (\n  SELECT * FROM updated\n  UNION ALL\n  SELECT estado.usuario_id, estado.xp_total, estado.nivel_atual, estado.titulo_nivel, estado.xp_proximo_nivel\n  FROM estado\n  WHERE NOT EXISTS (SELECT 1 FROM updated)\n)\nSELECT\n  resultado.usuario_id,\n  resultado.xp_total,\n  resultado.nivel_atual,\n  resultado.titulo_nivel,\n  resultado.xp_proximo_nivel,\n  $2::numeric AS xp_ganho,\n  $3::integer AS quests_concluidas,\n  $4::integer AS reinicios,\n  $5::jsonb AS novas_quests,\n  $6::jsonb AS atualizacoes,\n  $7::jsonb AS estado_inicial\nFROM resultado;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id, $json.xp_ganho, $json.quests_concluidas, $json.reinicios, JSON.stringify($json.novas_quests || []), JSON.stringify($json.atualizacoes || []), JSON.stringify($json.estado_inicial || {}) ] }}"
        }
      },
      "id": "a69c8b0c-0e94-4c32-bf79-739e528fdf2f",
      "name": "Atualizar Estado",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2416,
        -64
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH personalizadas AS (\n  SELECT\n    uq.id,\n    uq.status,\n    uq.catalogo_id,\n    uq.ativado_em,\n    uq.atualizado_em,\n    COALESCE(uq.config, '{}'::jsonb) AS config\n  FROM public.usuarios_quest uq\n  WHERE uq.usuario_id = $1::uuid\n)\nSELECT\n  rj.usuario_id,\n  rj.xp_total,\n  rj.nivel_atual,\n  rj.titulo_nivel,\n  rj.xp_proximo_nivel,\n  rj.sequencia_atual,\n  rj.sequencia_recorde,\n  rj.meta_sequencia_codigo,\n  rj.proxima_meta_codigo,\n  rj.sequencia_status,\n  COALESCE(jsonb_agg(personalizadas) FILTER (WHERE personalizadas.id IS NOT NULL), '[]'::jsonb) AS quests_personalizadas\nFROM public.usuarios_conquistas rj\nLEFT JOIN personalizadas ON TRUE\nWHERE rj.usuario_id = $1::uuid\nGROUP BY\n  rj.usuario_id,\n  rj.xp_total,\n  rj.nivel_atual,\n  rj.titulo_nivel,\n  rj.xp_proximo_nivel,\n  rj.sequencia_atual,\n  rj.sequencia_recorde,\n  rj.meta_sequencia_codigo,\n  rj.proxima_meta_codigo,\n  rj.sequencia_status;",
        "options": {
          "queryReplacement": "={{ [ $json.usuario_id ] }}"
        }
      },
      "id": "31846bc5-a1d4-4c61-b28f-76ee8b7eb175",
      "name": "Buscar Snapshot Final",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2848,
        -64
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const estadoItems = $items(\"Atualizar Estado\", 0, 0) || [];\nconst estadoAtualizado = (estadoItems[0] && estadoItems[0].json) || {};\nconst snapshotFinal = $input.item.json || {};\n\nconst parseList = (value) => {\n  if (!value) return [];\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') {\n    try {\n      const parsed = JSON.parse(value);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch (error) {\n      return [];\n    }\n  }\n  return [];\n};\n\nconst toNumber = (value, fallback = 0) => {\n  const numeric = Number(value);\n  return Number.isFinite(numeric) ? numeric : fallback;\n};\n\nconst filaItems = $items(\"Preparar Operacoes\", 0, 0) || [];\nconst filaEspera = parseList(filaItems[0]?.json?.fila_espera);\n\nreturn [{\n  json: {\n    usuario_id: estadoAtualizado.usuario_id ?? snapshotFinal.usuario_id ?? null,\n    xp_total: toNumber(estadoAtualizado.xp_total ?? snapshotFinal.xp_total ?? 0),\n    nivel_atual: estadoAtualizado.nivel_atual ?? snapshotFinal.nivel_atual ?? null,\n    titulo_nivel: estadoAtualizado.titulo_nivel ?? snapshotFinal.titulo_nivel ?? null,\n    xp_proximo_nivel: toNumber(estadoAtualizado.xp_proximo_nivel ?? snapshotFinal.xp_proximo_nivel ?? 0),\n    xp_ganho: toNumber(estadoAtualizado.xp_ganho, 0),\n    quests_concluidas_no_evento: toNumber(estadoAtualizado.quests_concluidas, 0),\n    reinicios_registrados: toNumber(estadoAtualizado.reinicios, 0),\n    novas_quests_registradas: parseList(estadoAtualizado.novas_quests),\n    atualizacoes_processadas: parseList(estadoAtualizado.atualizacoes),\n    fila_espera: filaEspera,\n    snapshot_final: snapshotFinal\n  }\n}];"
      },
      "id": "fae8c7dd-93b3-413c-8a98-7d1dfbb591ec",
      "name": "Montar Resposta",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3072,
        -64
      ]
    }
  ],
  "connections": {
    "start": {
      "main": [
        [
          {
            "node": "Normalizar Entrada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalizar Entrada": {
      "main": [
        [
          {
            "node": "Buscar Estado e Quests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Estado e Quests": {
      "main": [
        [
          {
            "node": "Preparar Operacoes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Inserir Instancias": {
      "main": [
        [
          {
            "node": "Aplicar Atualizacoes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aplicar Atualizacoes": {
      "main": [
        [
          {
            "node": "Atualizar Estado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Atualizar Estado": {
      "main": [
        [
          {
            "node": "Atualizar Jornada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Atualizar Jornada": {
      "main": [
        [
          {
            "node": "Buscar Snapshot Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Snapshot Final": {
      "main": [
        [
          {
            "node": "Montar Resposta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Operacoes": {
      "main": [
        [
          {
            "node": "Verificar e Criar Quest Inicial",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verificar e Criar Quest Inicial": {
      "main": [
        [
          {
            "node": "Inserir Instancias",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": {
    "start": [
      {
        "json": {
          "usuario_id": "d949d81c-9235-41ce-8b3b-6b5d593c5e24",
          "quests_personalizadas": "[{\"titulo\":\"Prática diária de respiração consciente para foco\",\"descricao\":\"Executar exercícios de respiração consciente todos os dias para reduzir ansiedade e manter o foco presente durante o trabalho.\",\"contexto_origem\":\"gestão da ansiedade e foco na mente agitada\",\"prioridade\":\"alta\",\"recorrencia\":\"diaria\",\"prazo_inicio\":\"2025-11-24\",\"prazo_fim\":\"2025-11-30\",\"progresso_meta\":7,\"status_inicial\":\"pendente\",\"area_vida_id\":\"11111111-1111-4111-8111-111111111111\",\"sabotador_id\":null,\"insight_id\":\"8427c12a-0414-4c5e-a6be-b6f65598d97d\",\"complexidade\":2,\"payload_extra\":{\"canal\":\"app\"}},{\"titulo\":\"Dividir metas do app em etapas diárias realistas\",\"descricao\":\"Fracionar as grandes metas do desenvolvimento do app em pequenas tarefas diárias para reduzir a pressão do prazo e celebrar cada avanço.\",\"contexto_origem\":\"controle do perfeccionismo e pressão interna para cumprir prazos\",\"prioridade\":\"alta\",\"recorrencia\":\"diaria\",\"prazo_inicio\":\"2025-11-24\",\"prazo_fim\":\"2025-11-30\",\"progresso_meta\":7,\"status_inicial\":\"pendente\",\"area_vida_id\":\"22222222-2222-4222-8222-222222222222\",\"sabotador_id\":null,\"insight_id\":\"8427c12a-0414-4c5e-a6be-b6f65598d97d\",\"complexidade\":3,\"payload_extra\":{\"canal\":\"app\"}},{\"titulo\":\"Pausas conscientes com técnica Pomodoro\",\"descricao\":\"Implementar pausas regulares usando a técnica Pomodoro para evitar sobrecarga mental e manter energia durante o desenvolvimento do app.\",\"contexto_origem\":\"risco de sobrecarga mental por longas horas de trabalho sem pausas\",\"prioridade\":\"alta\",\"recorrencia\":\"diaria\",\"prazo_inicio\":\"2025-11-24\",\"prazo_fim\":\"2025-11-30\",\"progresso_meta\":7,\"status_inicial\":\"pendente\",\"area_vida_id\":\"22222222-2222-4222-8222-222222222222\",\"sabotador_id\":null,\"insight_id\":\"8029200f-c852-46cc-a926-e95123940707\",\"complexidade\":3,\"payload_extra\":{\"canal\":\"app\"}}]",
          "atualizacoes_status": "[]"
        }
      }
    ]
  },
  "activeVersionId": null,
  "shared": [
    {
      "createdAt": "2025-11-07T16:03:52.061Z",
      "role": "workflow:owner",
      "workflowId": "bTeLj5qOKQo9PDMO",
      "projectId": "u1M57XAwIiLpPwjp",
      "project": {
        "createdAt": "2025-09-16T16:13:20.606Z",
        "id": "u1M57XAwIiLpPwjp",
        "name": "Aldo Santos <lindualdo@hotmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "createdAt": "2025-09-16T16:13:20.606Z",
            "userId": "fa864d51-475e-4765-b3b4-12788525a3e6",
            "projectId": "u1M57XAwIiLpPwjp",
            "user": {
              "createdAt": "2025-09-16T16:13:20.056Z",
              "id": "fa864d51-475e-4765-b3b4-12788525a3e6",
              "email": "lindualdo@hotmail.com",
              "firstName": "Aldo",
              "lastName": "Santos",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-09-16T16:22:10.583Z",
                "personalization_survey_n8n_version": "1.108.1"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "jUAvu7DUAzyqZhJd",
                "userActivatedAt": 1758041156747,
                "easyAIWorkflowOnboarded": true,
                "dismissedCallouts": {
                  "preBuiltAgentsModalCallout": true
                },
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1759918723295
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": null
}
