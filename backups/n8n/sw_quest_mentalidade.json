{
  "createdAt": "2025-12-22T00:00:00.000Z",
  "id": "sw_quest_mentalidade_v1",
  "name": "sw_quest_mentalidade",
  "description": "Especialista em quests de mentalidade (TCC, Estoicismo, regulação emocional)",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            { "name": "usuario_id" },
            { "name": "chat_id" },
            { "name": "contexto", "type": "object" }
          ]
        }
      },
      "id": "start-mentalidade",
      "name": "start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Buscar quests do catálogo: TCC, Estoicismo, Boas Práticas\nSELECT \n  id,\n  codigo,\n  titulo,\n  descricao,\n  categoria,\n  base_cientifica,\n  xp\nFROM quests_catalogo\nWHERE ativo = true\n  AND categoria IN ('tcc', 'estoicismo', 'boa_pratica_geral')\nORDER BY nivel_prioridade DESC, RANDOM()\nLIMIT 10;",
        "options": {}
      },
      "id": "buscar-catalogo-ment",
      "name": "Buscar Catálogo",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [420, 300],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Buscar quests existentes do tipo mentalidade (últimos 30 dias)\nSELECT \n  uq.id,\n  uq.catalogo_id,\n  uq.status,\n  uq.ativado_em,\n  uq.config->>'titulo' as titulo,\n  qc.categoria,\n  qc.codigo\nFROM usuarios_quest uq\nLEFT JOIN quests_catalogo qc ON qc.id = uq.catalogo_id\nWHERE uq.usuario_id = $1::uuid\n  AND uq.status IN ('ativa', 'disponivel')\n  AND (\n    qc.categoria IN ('tcc', 'estoicismo', 'boa_pratica_geral')\n    OR (uq.catalogo_id = '00000000-0000-0000-0000-000000000001' \n        AND uq.config->>'contexto_origem' LIKE '%mental%')\n  )\n  AND uq.ativado_em > NOW() - INTERVAL '30 days'\nORDER BY uq.ativado_em DESC;",
        "options": {
          "queryReplacement": "={{ [$json.usuario_id] }}"
        }
      },
      "id": "buscar-existentes-ment",
      "name": "Buscar Existentes",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [640, 300],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Anti-Duplicação: Keywords + Cooldown\n// Jaccard similarity para títulos\n\nfunction extrairKeywords(texto) {\n  if (!texto) return new Set();\n  return new Set(\n    texto.toLowerCase()\n      .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') // remove acentos\n      .split(/\\s+/)\n      .filter(w => w.length > 3)\n      .filter(w => !['para', 'com', 'uma', 'seu', 'sua', 'que', 'sobre'].includes(w))\n  );\n}\n\nfunction calcularSimilaridade(titulo1, titulo2) {\n  const k1 = extrairKeywords(titulo1);\n  const k2 = extrairKeywords(titulo2);\n  \n  if (k1.size === 0 || k2.size === 0) return 0;\n  \n  const intersecao = [...k1].filter(w => k2.has(w)).length;\n  const uniao = new Set([...k1, ...k2]).size;\n  \n  return intersecao / uniao; // Jaccard\n}\n\nconst entrada = $('start').first().json;\nconst catalogo = $input.all().map(i => i.json);\nconst existentes = $items('Buscar Existentes', 0, 0).map(i => i.json);\n\nconst contexto = entrada.contexto || {};\nconst humor = contexto.humor || 6;\nconst energia = contexto.energia || 6;\n\n// Temas baseados no contexto\nconst temas = [];\nif (humor < 4 || energia < 4) temas.push('regulacao_emocional');\nif (humor < 5 || energia < 5) temas.push('bem_estar');\n\n// Filtrar catálogo por temas EXCLUINDO já usados\nconst catalogoIdsUsados = new Set(existentes.map(e => e.catalogo_id).filter(Boolean));\nconst catalogoDisponivel = catalogo.filter(q => !catalogoIdsUsados.has(q.id));\n\n// Verificar duplicação por keywords nos últimos 14 dias\nconst agora = new Date();\nconst existentesRecentes = existentes.filter(e => {\n  const diff = (agora - new Date(e.ativado_em)) / (1000 * 60 * 60 * 24);\n  return diff <= 14;\n});\n\nconst bloqueios = [];\nfor (const quest of catalogoDisponivel) {\n  for (const existente of existentesRecentes) {\n    const sim = calcularSimilaridade(quest.titulo, existente.titulo);\n    if (sim > 0.5) {\n      bloqueios.push({\n        catalogo_id: quest.id,\n        motivo: 'similaridade_alta',\n        similaridade: sim.toFixed(2),\n        quest_existente: existente.titulo\n      });\n    }\n  }\n}\n\n// Filtrar catálogo final (sem bloqueados)\nconst catalogoIdsBloqueados = new Set(bloqueios.map(b => b.catalogo_id));\nconst catalogoFinal = catalogoDisponivel.filter(q => !catalogoIdsBloqueados.has(q.id));\n\nconst podeCriar = catalogoFinal.length > 0;\n\nreturn [{\n  json: {\n    usuario_id: entrada.usuario_id,\n    chat_id: entrada.chat_id,\n    pode_criar: podeCriar,\n    motivo: podeCriar ? 'ok' : 'sem_opcoes_disponiveis',\n    catalogo_disponivel: catalogoFinal,\n    bloqueios: bloqueios,\n    contexto: contexto\n  }\n}];"
      },
      "id": "verificar-dup-ment",
      "name": "Verificar Duplicação",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "pode_criar",
              "leftValue": "={{ $json.pode_criar }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "pode-criar-ment",
      "name": "Pode Criar?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "jsCode": "// Saída sem criar\nconst input = $input.item.json || {};\n\nreturn [{\n  json: {\n    sucesso: false,\n    tipo: 'mentalidade',\n    motivo: input.motivo || 'bloqueado',\n    bloqueios: input.bloqueios || [],\n    quest_criada: null\n  }\n}];"
      },
      "id": "saida-sem-criar-ment",
      "name": "Saída Sem Criar",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 500]
    },
    {
      "parameters": {
        "jsCode": "// Selecionar quest do catálogo (prioridade humor/energia)\nconst input = $input.item.json || {};\nconst catalogo = input.catalogo_disponivel || [];\nconst contexto = input.contexto || {};\n\nif (catalogo.length === 0) {\n  throw new Error('Nenhuma quest disponível no catálogo');\n}\n\n// Priorizar por humor/energia\nlet questSelecionada;\nif (contexto.humor < 4 || contexto.energia < 4) {\n  // Priorizar TCC\n  questSelecionada = catalogo.find(q => q.categoria === 'tcc') || catalogo[0];\n} else if (contexto.humor < 5 || contexto.energia < 5) {\n  // Priorizar Estoicismo ou Boas Práticas\n  questSelecionada = catalogo.find(q => q.categoria === 'estoicismo') \n    || catalogo.find(q => q.categoria === 'boa_pratica_geral')\n    || catalogo[0];\n} else {\n  // Qualquer uma\n  questSelecionada = catalogo[0];\n}\n\nreturn [{\n  json: {\n    usuario_id: input.usuario_id,\n    chat_id: input.chat_id,\n    quest_catalogo: questSelecionada,\n    contexto: contexto\n  }\n}];"
      },
      "id": "selecionar-quest-ment",
      "name": "Selecionar Quest",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "inputText": "={{ $json.quest_catalogo.titulo }}\n\nDescrição original: {{ $json.quest_catalogo.descricao }}\n\nContexto conversa: {{ $json.contexto.mensagem_relevante || 'usuário mencionou dificuldades emocionais' }}\nHumor: {{ $json.contexto.humor }}/10\nEnergia: {{ $json.contexto.energia }}/10",
        "options": {
          "systemMessage": "<role>\nVocê é o Especialista em Mentalidade do MindQuest.\nSua função é adaptar técnicas de TCC, Estoicismo e boas práticas ao contexto real do usuário.\n</role>\n\n<objective>\nGerar quest personalizada que conecte a técnica científica com a situação atual.\nSucesso = título único + descrição acionável específica ao contexto.\n</objective>\n\n<rules>\n1. MANTER técnica original (base científica intacta)\n2. ADAPTAR título e descrição ao contexto da conversa\n3. TÍTULO: máx 80 chars, específico, acionável\n4. DESCRIÇÃO: passos claros usando contexto real\n5. NUNCA genérico - sempre mencionar situação específica\n</rules>\n\n<workflow>\n1. Identifique a situação do usuário (humor, energia, contexto)\n2. Conecte com a técnica do catálogo\n3. Adapte linguagem ao momento atual\n4. Gere título e descrição personalizados\n</workflow>\n\n<examples>\n<example>\nInput: Técnica 'Respiração 4-7-8', Contexto: 'ansioso com prazo do app'\nOutput:\n{\n  \"titulo\": \"Respiração 4-7-8 antes de codar o app\",\n  \"descricao\": \"Antes de começar a sessão de desenvolvimento, faça 3 ciclos de respiração 4-7-8 para reduzir a ansiedade do prazo e focar melhor.\"\n}\n</example>\n</examples>\n\n<output_format>\nRetorne APENAS JSON válido:\n{\n  \"titulo\": \"string máx 80 chars\",\n  \"descricao\": \"string acionável\"\n}\n</output_format>"
        }
      },
      "id": "adaptar-ia-ment",
      "name": "Adaptar ao Contexto",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [1520, 300],
      "credentials": {
        "openRouterApi": {
          "id": "your-openrouter-id",
          "name": "OpenRouter"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "fromJson",
        "jsonSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"titulo\": { \"type\": \"string\" },\n    \"descricao\": { \"type\": \"string\" }\n  },\n  \"required\": [\"titulo\", \"descricao\"]\n}"
      },
      "id": "parser-adapt-ment",
      "name": "Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [1700, 300]
    },
    {
      "parameters": {
        "jsCode": "// Combinar quest adaptada com dados originais\nconst entrada = $items('Selecionar Quest', 0, 0)[0].json;\nconst adaptado = $input.item.json;\n\nreturn [{\n  json: {\n    usuario_id: entrada.usuario_id,\n    catalogo_id: entrada.quest_catalogo.id,\n    titulo: adaptado.titulo,\n    descricao: adaptado.descricao,\n    contexto: entrada.contexto,\n    base_cientifica: entrada.quest_catalogo.base_cientifica\n  }\n}];"
      },
      "id": "preparar-insert-ment",
      "name": "Preparar Insert",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1880, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Inserir quest de mentalidade adaptada\nWITH inserted AS (\n  INSERT INTO usuarios_quest (\n    usuario_id,\n    catalogo_id,\n    status,\n    config,\n    ativado_em\n  )\n  VALUES (\n    $1::uuid,\n    $2::uuid,\n    'disponivel',\n    $3::jsonb,\n    NOW()\n  )\n  RETURNING id, catalogo_id, status, config, ativado_em\n)\nSELECT \n  i.id,\n  i.catalogo_id,\n  i.status,\n  i.config,\n  i.ativado_em,\n  qc.titulo as catalogo_titulo,\n  qc.categoria\nFROM inserted i\nJOIN quests_catalogo qc ON qc.id = i.catalogo_id;",
        "options": {
          "queryReplacement": "={{ [\n  $json.usuario_id,\n  $json.catalogo_id,\n  JSON.stringify({\n    titulo: $json.titulo,\n    descricao: $json.descricao,\n    contexto_origem: 'mentalidade_adaptado',\n    base_cientifica: $json.base_cientifica,\n    humor: $json.contexto.humor,\n    energia: $json.contexto.energia\n  })\n] }}"
        }
      },
      "id": "inserir-quest-ment",
      "name": "Inserir Quest",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [2060, 300],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Montar resposta final\nconst quest = $input.item.json || {};\n\nreturn [{\n  json: {\n    sucesso: true,\n    tipo: 'mentalidade',\n    quest_criada: {\n      id: quest.id,\n      catalogo_id: quest.catalogo_id,\n      titulo: quest.config?.titulo || quest.catalogo_titulo,\n      categoria: quest.categoria,\n      status: quest.status\n    }\n  }\n}];"
      },
      "id": "saida-sucesso-ment",
      "name": "Saída Sucesso",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1740, 300]
    }
  ],
  "connections": {
    "start": {
      "main": [[{ "node": "Buscar Catálogo", "type": "main", "index": 0 }]]
    },
    "Buscar Catálogo": {
      "main": [[{ "node": "Buscar Existentes", "type": "main", "index": 0 }]]
    },
    "Buscar Existentes": {
      "main": [[{ "node": "Verificar Duplicação", "type": "main", "index": 0 }]]
    },
    "Verificar Duplicação": {
      "main": [[{ "node": "Pode Criar?", "type": "main", "index": 0 }]]
    },
    "Pode Criar?": {
      "main": [
        [{ "node": "Selecionar Quest", "type": "main", "index": 0 }],
        [{ "node": "Saída Sem Criar", "type": "main", "index": 0 }]
      ]
    },
    "Selecionar Quest": {
      "main": [[{ "node": "Adaptar ao Contexto", "type": "main", "index": 0 }]]
    },
    "Adaptar ao Contexto": {
      "main": [[{ "node": "Parser", "type": "main", "index": 0 }]]
    },
    "Parser": {
      "main": [[{ "node": "Preparar Insert", "type": "main", "index": 0 }]]
    },
    "Preparar Insert": {
      "main": [[{ "node": "Inserir Quest", "type": "main", "index": 0 }]]
    },
    "Inserir Quest": {
      "main": [[{ "node": "Saída Sucesso", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "activeVersionId": null,
  "shared": [],
  "tags": []
}

