{
  "createdAt": "2025-11-05T17:35:05.601Z",
  "id": "yvg9NkBsLF3mbr5f",
  "name": "webhook_quests",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        160,
        64
      ],
      "id": "72ed82d5-b607-41c7-8abf-157f402e3380",
      "name": "Responder"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  quests.id AS instancia_id,\n  quests.meta_codigo,\n  quests.status,\n  quests.progresso_meta,\n  quests.progresso_atual,\n  quests.concluido_em,\n  quests.xp_concedido,\n  quests.contexto_origem,\n  quests.atualizado_em,\n  quests.area_vida_id,\n  quests.sabotador_id,\n  quests.insight_id,\n  quests.complexidade,\n  quests.titulo,\n  quests.descricao,\n  quests.config,\n  quests.xp_recompensa,\n  quests.meta_codigo AS modelo_codigo,\n  quests.tipo\nFROM (\n  SELECT\n    uq.id,\n    uq.status,\n    uq.progresso_meta,\n    uq.progresso_atual,\n    uq.xp_concedido,\n    uq.contexto_origem,\n    uq.concluido_em,\n    uq.atualizado_em,\n    uq.area_vida_id,\n    uq.sabotador_id,\n    uq.insight_id,\n    uq.complexidade,\n    uq.config,\n    COALESCE(uq.config->>'meta_codigo', uq.id::text) AS meta_codigo,\n    COALESCE(uq.config->>'titulo', 'Quest personalizada') AS titulo,\n    uq.config->>'descricao' AS descricao,\n    uq.config->>'prioridade' AS prioridade,\n    uq.config->>'recorrencia' AS recorrencia,\n    COALESCE((uq.config->>'xp_recompensa')::int, NULL) AS xp_recompensa,\n    uq.config->>'tipo' AS tipo\n  FROM public.usuarios_quest uq\n  WHERE uq.usuario_id = $1::uuid\n) AS quests\nORDER BY\n  CASE quests.status\n    WHEN 'ativa' THEN 0\n    WHEN 'pendente' THEN 1\n    WHEN 'reiniciada' THEN 2\n    WHEN 'concluida' THEN 3\n    WHEN 'vencida' THEN 4\n    WHEN 'cancelada' THEN 5\n    ELSE 6\n  END,\n  quests.atualizado_em DESC\nLIMIT 20;\n",
        "options": {
          "queryReplacement": "={{ [$json.usuario_id] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -432,
        -96
      ],
      "id": "f9872254-5402-4312-b0a4-a5946e4079f1",
      "name": "Listar Usuarios Quest",
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  usuario_id,\n  xp_total,\n  xp_proximo_nivel,\n  nivel_atual,\n  titulo_nivel,\n  sequencia_atual,\n  sequencia_recorde,\n  meta_sequencia_codigo,\n  proxima_meta_codigo,\n  sequencia_status\nFROM public.usuarios_conquistas\nWHERE usuario_id = $1::uuid;",
        "options": {
          "queryReplacement": "={{ [$json.usuario_id] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -656,
        64
      ],
      "id": "3df2788c-8fca-4859-9ae5-a42c0df6b787",
      "name": "Ler Usuarios Conquistas",
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first()?.json ?? {};\nconst query = input.query ?? {};\nconst body = input.body ?? {};\n\nconst candidate = [\n  query.usuario_id,\n  query.user_id,\n  query.id_usuario,\n  body.usuario_id,\n  body.user_id,\n  body.id_usuario,\n  input.headers?.usuario_id,\n  input.headers?.user_id,\n].find((value) => typeof value === 'string' && value.trim().length > 0);\n\nif (!candidate) {\n  throw new Error('usuario_id obrigatório');\n}\n\nreturn [{\n  json: {\n    usuario_id: candidate.trim(),\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -896,
        64
      ],
      "id": "214c289c-60ca-4d55-8f66-e699a42bd44a",
      "name": "Validar Entrada"
    },
    {
      "parameters": {
        "path": "quests",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -1120,
        64
      ],
      "id": "49e50fe8-9bec-4d22-9793-1d88c78fd766",
      "name": "Webhook",
      "webhookId": "5d8f7b9a-4f2e-4c7b-9d32-quests"
    },
    {
      "parameters": {
        "jsCode": "const getItem = (nodeName) => {\n  const list = $items(nodeName, 0, 0) || [];\n  return list[0]?.json || {};\n};\n\nconst getItems = (nodeName) => {\n  const list = $items(nodeName, 0, 0) || [];\n  return list.map((entry) => entry?.json || {});\n};\n\nconst toNumber = (value, fallback = null) => {\n  if (value === null || value === undefined || value === '') return fallback;\n  const coerced = Number(value);\n  return Number.isFinite(coerced) ? coerced : fallback;\n};\n\nconst parseJson = (value) => {\n  if (!value) return null;\n  if (typeof value === 'object') return value;\n  if (typeof value !== 'string') return null;\n  const trimmed = value.trim();\n  if (!trimmed) return null;\n  try {\n    return JSON.parse(trimmed);\n  } catch (_err) {\n    return null;\n  }\n};\n\nfunction humanizeDate(iso) {\n  if (!iso) return null;\n  const date = new Date(iso);\n  if (Number.isNaN(date.getTime())) return null;\n  const now = new Date();\n  const diffMs = Math.max(0, now.getTime() - date.getTime());\n  const days = Math.floor(diffMs / 86_400_000);\n  const hours = Math.floor((diffMs % 86_400_000) / 3_600_000);\n  const parts = [];\n  if (days > 0) parts.push(`${days} dia${days > 1 ? 's' : ''}`);\n  if (hours > 0) parts.push(`${hours} h`);\n  if (parts.length === 0) return 'agora';\n  return `há ${parts.join(' e ')}`;\n}\n\nconst estado = getItem('Ler Usuarios Conquistas');\nconst questsRaw = getItems('Listar Usuarios Quest');\n\n// Encontrar a primeira quest ativa ou pendente\nconst questAtiva = questsRaw\n  .filter((q) => q.status === 'ativa' || q.status === 'pendente')\n  .sort((a, b) => {\n    // Prioriza 'ativa' sobre 'pendente'\n    if (a.status === 'ativa' && b.status !== 'ativa') return -1;\n    if (a.status !== 'ativa' && b.status === 'ativa') return 1;\n    // Depois ordena por atualizado_em (mais recente primeiro)\n    const dateA = a.atualizado_em ? new Date(a.atualizado_em).getTime() : 0;\n    const dateB = b.atualizado_em ? new Date(b.atualizado_em).getTime() : 0;\n    return dateB - dateA;\n  })[0] || null;\n\n// Formatar quest\nlet quest = null;\nif (questAtiva) {\n  const config = parseJson(questAtiva.config) || {};\n  const meta = Math.max(toNumber(questAtiva.progresso_meta, 1) || 1, 1);\n  const atual = Math.min(toNumber(questAtiva.progresso_atual, 0) || 0, meta);\n  const percentual = meta > 0 ? Math.round((atual / meta) * 100) : 0;\n  \n  // XP recompensa: prioriza xp_recompensa da quest, depois config, depois padrão\n  const xpRecompensa = toNumber(questAtiva.xp_recompensa, null) \n    || toNumber(config?.xp_recompensa, null)\n    || 150;\n  \n  quest = {\n    id: questAtiva.instancia_id || questAtiva.meta_codigo || null,\n    titulo: questAtiva.titulo || config?.titulo || 'Quest personalizada',\n    descricao: questAtiva.descricao || config?.descricao || null,\n    status: questAtiva.status || 'pendente',\n    prioridade: questAtiva.prioridade || config?.prioridade || null,\n    recorrencia: questAtiva.recorrencia || config?.recorrencia || null,\n    progresso: {\n      atual,\n      meta,\n      percentual,\n      label: `${atual}/${meta}`,\n    },\n    xp_recompensa: xpRecompensa,\n    ultima_atualizacao: questAtiva.atualizado_em || null,\n    ultima_atualizacao_label: humanizeDate(questAtiva.atualizado_em),\n  };\n}\n\n// Calcular snapshot\nconst totalPersonalizadas = questsRaw.length;\nconst totalConcluidas = questsRaw.filter((q) => q.status === 'concluida' || q.concluido_em).length;\n\n// Calcular XP total (soma de xp_concedido das quests concluídas)\nlet xpBaseTotal = 0;\nlet xpBonusTotal = 0;\nquestsRaw.forEach((q) => {\n  if (q.status === 'concluida' || q.concluido_em) {\n    const xpConcedido = toNumber(q.xp_concedido, 0) || 0;\n    // Assumindo que xp_concedido já inclui base + bonus, mas vamos tentar separar\n    // Se não conseguir separar, coloca tudo em xp_base_total\n    xpBaseTotal += xpConcedido;\n  }\n});\n\n// Valores padrão de recompensas\nconst xpBase = 150;\nconst xpBonusRecorrencia = 30;\n\n// Gerar beneficios\nconst beneficios = [];\nbeneficios.push(`+${xpBase} XP base`);\nif (xpBonusRecorrencia > 0) beneficios.push(`+${xpBonusRecorrencia} XP bônus (recorrência)`);\nbeneficios.push('Novo insight aplicado na prática');\nbeneficios.push('Progresso em hábitos chaves');\n\n// Formatar todas as quests para o formato QuestSnapshot\nconst questsPersonalizadas = questsRaw.map((q) => {\n  const config = parseJson(q.config) || {};\n  const xpRecompensa = toNumber(q.xp_recompensa, null) \n    || toNumber(config?.xp_recompensa, null)\n    || 150;\n  \n  return {\n    instancia_id: q.instancia_id || q.meta_codigo || null,\n    meta_codigo: q.meta_codigo || q.instancia_id || null,\n    titulo: q.titulo || config?.titulo || 'Quest personalizada',\n    descricao: q.descricao || config?.descricao || null,\n    status: q.status || 'pendente',\n    concluido_em: q.concluido_em || null,\n    progresso_meta: toNumber(q.progresso_meta, 1) || 1,\n    progresso_atual: toNumber(q.progresso_atual, 0) || 0,\n    xp_recompensa: xpRecompensa,\n    prioridade: q.prioridade || config?.prioridade || null,\n    recorrencia: q.recorrencia || config?.recorrencia || null,\n    atualizado_em: q.atualizado_em || null,\n  };\n});\n\nconst usuarioId = estado.usuario_id || $json.usuario_id || null;\n\n// Montar resposta com card_quests E quests_personalizadas (formato QuestSnapshot)\nconst response = {\n  success: true,\n  usuario_id: usuarioId,\n  // Formato QuestSnapshot (para loadQuestSnapshot)\n  xp_total: toNumber(estado.xp_total, 0) || 0,\n  xp_proximo_nivel: toNumber(estado.xp_proximo_nivel, null),\n  nivel_atual: toNumber(estado.nivel_atual, 1) || 1,\n  titulo_nivel: estado.titulo_nivel || null,\n  sequencia_atual: toNumber(estado.sequencia_atual, 0) || 0,\n  sequencia_recorde: toNumber(estado.sequencia_recorde, 0) || 0,\n  meta_sequencia_codigo: estado.meta_sequencia_codigo || null,\n  proxima_meta_codigo: estado.proxima_meta_codigo || null,\n  sequencia_status: estado.sequencia_status || null,\n  quests_personalizadas: questsPersonalizadas,\n  // Formato card_quests (para loadQuestsCard)\n  card_quests: {\n    quest,\n    snapshot: {\n      total_concluidas: totalConcluidas,\n      total_personalizadas: totalPersonalizadas,\n      xp_base_total: xpBaseTotal,\n      xp_bonus_total: xpBonusTotal,\n    },\n    beneficios,\n    recompensas: {\n      xp_base: xpBase,\n      xp_bonus_recorrencia: xpBonusRecorrencia,\n    },\n  },\n};\n\nreturn [{ json: response }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        64
      ],
      "id": "c5aa0b1b-c5c8-4519-8f41-54a1334ed198",
      "name": "Montar Resposta"
    },
    {
      "parameters": {},
      "id": "9e01dce7-45a6-4e8b-b32e-6debe17f9acd",
      "name": "Aguardar Dados",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -272,
        64
      ]
    }
  ],
  "connections": {
    "Ler Usuarios Conquistas": {
      "main": [
        [
          {
            "node": "Listar Usuarios Quest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Entrada": {
      "main": [
        [
          {
            "node": "Ler Usuarios Conquistas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Validar Entrada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Montar Resposta": {
      "main": [
        [
          {
            "node": "Responder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Listar Usuarios Quest": {
      "main": [
        [
          {
            "node": "Aguardar Dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aguardar Dados": {
      "main": [
        [
          {
            "node": "Montar Resposta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {
    "Webhook": [
      {
        "json": {
          "headers": {
            "host": "mindquest-n8n.cloudfy.live",
            "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 OPR/123.0.0.0",
            "accept": "*/*",
            "accept-encoding": "gzip, br",
            "accept-language": "en-US,en;q=0.9,pt-BR;q=0.8,pt-PT;q=0.7,pt;q=0.6,es;q=0.5",
            "cdn-loop": "cloudflare; loops=1",
            "cf-connecting-ip": "2001:818:e374:a600:4ed:251e:7048:6b3f",
            "cf-ipcountry": "PT",
            "cf-ray": "99cf6788cf6216a5-LIS",
            "cf-visitor": "{\"scheme\":\"https\"}",
            "origin": "http://localhost:5173",
            "priority": "u=1, i",
            "referer": "http://localhost:5173/",
            "sec-ch-ua": "\"Not;A=Brand\";v=\"99\", \"Opera\";v=\"123\", \"Chromium\";v=\"139\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"macOS\"",
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "cross-site",
            "x-forwarded-for": "172.68.103.43",
            "x-forwarded-host": "mindquest-n8n.cloudfy.live",
            "x-forwarded-port": "443",
            "x-forwarded-proto": "https",
            "x-forwarded-server": "d49265bfcab0",
            "x-real-ip": "172.68.103.43"
          },
          "params": {},
          "query": {
            "usuario_id": "d949d81c-9235-41ce-8b3b-6b5d593c5e24"
          },
          "body": {},
          "webhookUrl": "https://mindquest-n8n.cloudfy.live/webhook/quests",
          "executionMode": "production"
        }
      }
    ]
  },
  "versionId": "0a29f405-216f-4aa4-a200-9d528415a296",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-11-05T17:35:05.601Z",
      "role": "workflow:owner",
      "workflowId": "yvg9NkBsLF3mbr5f",
      "projectId": "u1M57XAwIiLpPwjp",
      "project": {
        "createdAt": "2025-09-16T16:13:20.606Z",
        "id": "u1M57XAwIiLpPwjp",
        "name": "Aldo Santos <lindualdo@hotmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "createdAt": "2025-09-16T16:13:20.606Z",
            "userId": "fa864d51-475e-4765-b3b4-12788525a3e6",
            "projectId": "u1M57XAwIiLpPwjp",
            "user": {
              "createdAt": "2025-09-16T16:13:20.056Z",
              "id": "fa864d51-475e-4765-b3b4-12788525a3e6",
              "email": "lindualdo@hotmail.com",
              "firstName": "Aldo",
              "lastName": "Santos",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-09-16T16:22:10.583Z",
                "personalization_survey_n8n_version": "1.108.1"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "jUAvu7DUAzyqZhJd",
                "userActivatedAt": 1758041156747,
                "easyAIWorkflowOnboarded": true,
                "dismissedCallouts": {
                  "preBuiltAgentsModalCallout": true
                },
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1759918723295
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": []
}
