{
  "createdAt": "2025-11-07T16:24:43.271Z",
  "id": "ItBastfCTkWxm41M",
  "name": "sw_xp_conversas",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "usuario_id"
            }
          ]
        }
      },
      "id": "326b374f-e11f-4bb6-894a-e56ee94d3a2e",
      "name": "start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        320,
        -80
      ]
    },
    {
      "parameters": {
        "jsCode": "const entrada = $input.item.json || {}; const usuarioId = entrada.usuario_id || entrada.id || $json.usuario_id; if (!usuarioId || typeof usuarioId !== 'string' || !usuarioId.trim()) { throw new Error('usuario_id obrigatório'); } return [{ json: { usuario_id: usuarioId.trim() } }];"
      },
      "id": "e9c33c31-b128-430b-8246-6da4ec9c0dd3",
      "name": "Validar Entrada",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        -80
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT usuario_id, xp_total, total_xp_hoje, sequencia_atual, sequencia_recorde, meta_sequencia_codigo, proxima_meta_codigo, ultima_conversa_em, sequencia_status FROM public.quest_estado_usuario WHERE usuario_id = $1::uuid;",
        "options": {
          "queryReplacement": "={{ [$json.usuario_id] }}"
        }
      },
      "id": "66d6d931-23f1-4105-a256-f8499ebcf3b7",
      "name": "Buscar Estado",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        784,
        -80
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n  uc.id,\n  date(uc.data_conversa) AS dia,\n  uc.tem_reflexao,\n  COALESCE(uc.total_palavras_usuario, 0) AS total_palavras_usuario,\n  uc.data_conversa,\n  uc.atualizado_em\nFROM public.usr_chat uc\nWHERE uc.usuario_id = $1::uuid\n  AND uc.data_conversa >= NOW() - INTERVAL '45 days'\nORDER BY dia ASC, uc.data_conversa ASC;",
        "options": {
          "queryReplacement": "={{ [$json.usuario_id] }}"
        }
      },
      "id": "ca3b95c0-e344-47bf-a8ef-500ac4061fb7",
      "name": "Buscar Conversas",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "alwaysOutputData": true,
      "position": [
        1024,
        -80
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const getItem = (nodeName) => {\n  const list = $items(nodeName, 0, 0) || [];\n  return list[0]?.json || null;\n};\nconst getItems = (nodeName) => {\n  const list = $items(nodeName) || [];\n  return list.map((entry) => entry?.json || {});\n};\nconst estado = getItem('Buscar Estado');\nif (!estado) {\n  throw new Error('Estado do usuário não encontrado');\n}\nconst conversas = getItems('Buscar Conversas');\nconst metas = [\n  { codigo: 'streak_003', dias: 3, bonus: 40 },\n  { codigo: 'streak_005', dias: 5, bonus: 60 },\n  { codigo: 'streak_007', dias: 7, bonus: 90 },\n  { codigo: 'streak_010', dias: 10, bonus: 130 },\n  { codigo: 'streak_015', dias: 15, bonus: 180 },\n  { codigo: 'streak_020', dias: 20, bonus: 250 },\n  { codigo: 'streak_025', dias: 25, bonus: 340 },\n  { codigo: 'streak_030', dias: 30, bonus: 450 },\n];\nconst metaTargets = metas.map((meta) => ({ codigo: meta.codigo, dias: meta.dias }));\nconst toTimestamp = (value) => {\n  if (!value) return null;\n  const date = new Date(value);\n  if (Number.isNaN(date.getTime())) return null;\n  return date.getTime();\n};\nconst toDay = (value) => {\n  if (!value && value !== 0) return null;\n  const date = new Date(value);\n  if (Number.isNaN(date.getTime())) return null;\n  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n};\nconst parseStatus = () => {\n  const raw = estado.sequencia_status;\n  if (!raw) return { estado: 'ativa', reinicios: 0, alvo_conversas: metaTargets[0].dias };\n  if (typeof raw === 'object') {\n    return { estado: 'ativa', alvo_conversas: metaTargets[0].dias, ...raw };\n  }\n  try {\n    return { estado: 'ativa', alvo_conversas: metaTargets[0].dias, ...(JSON.parse(raw) || {}) };\n  } catch (error) {\n    return { estado: 'ativa', reinicios: 0, alvo_conversas: metaTargets[0].dias };\n  }\n};\nconst determineNextMeta = (streak) => {\n  for (const meta of metaTargets) {\n    if (streak < meta.dias) {\n      return meta;\n    }\n  }\n  return metaTargets[metaTargets.length - 1];\n};\nconst status = parseStatus();\nconst msDia = 24 * 60 * 60 * 1000;\nconst conversasOrdenadas = conversas\n  .map((entrada) => {\n    const timestamp = toTimestamp(entrada.atualizado_em || entrada.data_conversa || entrada.dia);\n    const diaISO = toDay(entrada.atualizado_em || entrada.data_conversa || entrada.dia);\n    const diaISOTexto = diaISO ? diaISO.toISOString() : null;\n    return { ...entrada, timestamp, diaISO, diaISOTexto };\n  })\n  .filter((entrada) => entrada.diaISO && entrada.diaISOTexto && Number.isFinite(entrada.timestamp))\n  .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));\nconst ultimaRegistradaTimestamp = toTimestamp(estado.ultima_conversa_em);\nconst isConversaNova = (entrada) => {\n  if (!ultimaRegistradaTimestamp) return true;\n  return (entrada.timestamp || 0) > ultimaRegistradaTimestamp;\n};\nconst XP_POR_DIA = 75;\nlet xpGanho = 0;\nlet ultimoDiaPontuado = null;\nlet sequenciaAtual = 0;\nlet sequenciaRecordeCalculado = 0;\nlet reinicios = Number(status.reinicios) || 0;\nlet metaAlcancadaIdxAnterior = metas.findIndex((meta) => meta.codigo === estado.meta_sequencia_codigo);\nif (metaAlcancadaIdxAnterior < 0) metaAlcancadaIdxAnterior = -1;\nlet metaAlcancadaIdx = metaAlcancadaIdxAnterior;\nlet alvoIdx = Math.max(metaAlcancadaIdxAnterior + 1, 0);\nconst resetMetaIndices = () => {\n  metaAlcancadaIdxAnterior = -1;\n  metaAlcancadaIdx = -1;\n  alvoIdx = 0;\n};\nconst applyReset = () => {\n  if (sequenciaAtual > 0) {\n    reinicios += 1;\n  }\n  sequenciaAtual = 0;\n  resetMetaIndices();\n};\nlet ultimaTimestampProcessado = null;\nlet ultimoDiaSequencia = null;\nfor (const conversa of conversasOrdenadas) {\n  conversa.isNova = isConversaNova(conversa);\n  const diaISOTexto = conversa.diaISOTexto;\n  if (diaISOTexto && diaISOTexto !== ultimoDiaPontuado) {\n    xpGanho += XP_POR_DIA;\n    ultimoDiaPontuado = diaISOTexto;\n  }\n  if (ultimoDiaSequencia) {\n    const diffDias = Math.floor(\n      (conversa.diaISO.getTime() - ultimoDiaSequencia.getTime()) / msDia,\n    );\n    if (diffDias > 1) {\n      applyReset();\n    }\n  }\n  sequenciaAtual += 1;\n  ultimaTimestampProcessado = conversa.timestamp ?? ultimaTimestampProcessado ?? conversa.timestamp;\n  ultimoDiaSequencia = conversa.diaISO;\n  if (sequenciaAtual > sequenciaRecordeCalculado) {\n    sequenciaRecordeCalculado = sequenciaAtual;\n  }\n  while (alvoIdx < metas.length && sequenciaAtual >= metas[alvoIdx].dias) {\n    if (conversa.isNova && alvoIdx > metaAlcancadaIdxAnterior) {\n      xpGanho += metas[alvoIdx].bonus;\n    }\n    metaAlcancadaIdx = alvoIdx;\n    alvoIdx += 1;\n  }\n  metaAlcancadaIdxAnterior = metaAlcancadaIdx;\n}\nif (ultimoDiaSequencia) {\n  const agora = new Date();\n  const hojeUTC = new Date(Date.UTC(agora.getUTCFullYear(), agora.getUTCMonth(), agora.getUTCDate()));\n  const diffDiasFinal = Math.floor((hojeUTC.getTime() - ultimoDiaSequencia.getTime()) / msDia);\n  if (diffDiasFinal > 1) {\n    applyReset();\n  }\n}\nconst sequenciaRecorde = Math.max(sequenciaRecordeCalculado, Number(estado.sequencia_recorde) || 0);\nconst metaCodigoAtual = metaAlcancadaIdx >= 0 ? metas[metaAlcancadaIdx].codigo : metas[0].codigo;\nconst proximaMetaAlvo = determineNextMeta(sequenciaAtual);\nconst proximaCodigo = proximaMetaAlvo ? proximaMetaAlvo.codigo : null;\nconst alvoConversas = proximaMetaAlvo ? proximaMetaAlvo.dias : metaTargets[metaTargets.length - 1].dias;\nconst ultimaConversaISO = ultimaTimestampProcessado\n  ? new Date(ultimaTimestampProcessado).toISOString()\n  : estado.ultima_conversa_em || null;\nreturn [{\n  json: {\n    usuario_id: estado.usuario_id,\n    xp_ganho: xpGanho,\n    sequencia_atual: sequenciaAtual,\n    sequencia_recorde: sequenciaRecorde,\n    meta_sequencia_codigo: metaCodigoAtual,\n    proxima_meta_codigo: proximaCodigo,\n    ultima_conversa_em: ultimaConversaISO,\n    sequencia_status: { ...status, estado: 'ativa', reinicios, alvo_conversas: alvoConversas },\n    dias_processados: conversasOrdenadas.length,\n  },\n}];\n"
      },
      "id": "058360b4-97c0-40e1-942a-0f51563a8b5b",
      "name": "Calcular XP Conversas",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1264,
        -80
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT\n    $1::uuid AS usuario_id,\n    $2::int AS xp_ganho,\n    $3::int AS sequencia_atual,\n    $4::int AS sequencia_recorde,\n    $5::varchar AS meta_codigo,\n    $6::varchar AS proxima_codigo,\n    NULLIF($7::text, '')::timestamptz AS ultima_conversa_em,\n    $8::jsonb AS sequencia_status\n),\natualizado AS (\n  UPDATE public.quest_estado_usuario q\n  SET\n    xp_total = q.xp_total + payload.xp_ganho,\n    total_xp_hoje = q.total_xp_hoje + payload.xp_ganho,\n    sequencia_atual = payload.sequencia_atual,\n    sequencia_recorde = payload.sequencia_recorde,\n    meta_sequencia_codigo = payload.meta_codigo,\n    proxima_meta_codigo = payload.proxima_codigo,\n    ultima_conversa_em = COALESCE(payload.ultima_conversa_em, q.ultima_conversa_em),\n    sequencia_status = payload.sequencia_status,\n    atualizado_em = NOW()\n  FROM payload\n  WHERE q.usuario_id = payload.usuario_id\n  RETURNING q.usuario_id, payload.xp_ganho\n)\nSELECT\n  payload.usuario_id,\n  payload.xp_ganho,\n  payload.sequencia_atual,\n  payload.sequencia_recorde\nFROM payload\nLEFT JOIN atualizado ON atualizado.usuario_id = payload.usuario_id;",
        "options": {
          "queryReplacement": "={{ [$json.usuario_id, $json.xp_ganho, $json.sequencia_atual, $json.sequencia_recorde, $json.meta_sequencia_codigo, $json.proxima_meta_codigo, ($json.ultima_conversa_em && $json.ultima_conversa_em !== '' ? $json.ultima_conversa_em : null), JSON.stringify($json.sequencia_status || {})] }}"
        }
      },
      "id": "e2cbf8e5-6001-4ff5-bcbf-d7c87520c0db",
      "name": "Atualizar Estado",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1520,
        -80
      ],
      "credentials": {
        "postgres": {
          "id": "8ySWxtSO7gYK5uue",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "71Ru87yaRA5SNjOQ",
          "mode": "list",
          "cachedResultUrl": "/workflow/71Ru87yaRA5SNjOQ",
          "cachedResultName": "sw_calcula_jornada"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "usuario_id": "={{ $json.usuario_id }}"
          },
          "matchingColumns": [
            "usuario_id"
          ],
          "schema": [
            {
              "id": "usuario_id",
              "displayName": "usuario_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "dce52876-920d-4a48-b5e2-973f6b3c0fa3",
      "name": "Atualizar Jornada",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1760,
        -80
      ]
    },
    {
      "parameters": {
        "jsCode": "const entrada = $items('Validar Entrada', 0, 0) || [];\nconst payload = entrada[0]?.json || {};\nreturn [{ json: { usuario_id: payload.usuario_id || null } }];"
      },
      "id": "3b8dac55-e5bc-4080-9c31-56525a7c026a",
      "name": "Retornar Resultado",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1984,
        -80
      ]
    }
  ],
  "connections": {
    "start": {
      "main": [
        [
          {
            "node": "Validar Entrada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Entrada": {
      "main": [
        [
          {
            "node": "Buscar Estado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Estado": {
      "main": [
        [
          {
            "node": "Buscar Conversas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Conversas": {
      "main": [
        [
          {
            "node": "Calcular XP Conversas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calcular XP Conversas": {
      "main": [
        [
          {
            "node": "Atualizar Estado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Atualizar Estado": {
      "main": [
        [
          {
            "node": "Atualizar Jornada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Atualizar Jornada": {
      "main": [
        [
          {
            "node": "Retornar Resultado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {
    "start": [
      {
        "json": {
          "usuario_id": "d949d81c-9235-41ce-8b3b-6b5d593c5e24"
        }
      }
    ]
  },
  "versionId": "104da218-3362-4ad1-91a7-ff949b786a83",
  "triggerCount": 0,
  "shared": [
    {
      "createdAt": "2025-11-07T16:24:43.271Z",
      "role": "workflow:owner",
      "workflowId": "ItBastfCTkWxm41M",
      "projectId": "u1M57XAwIiLpPwjp",
      "project": {
        "createdAt": "2025-09-16T16:13:20.606Z",
        "id": "u1M57XAwIiLpPwjp",
        "name": "Aldo Santos <lindualdo@hotmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "createdAt": "2025-09-16T16:13:20.606Z",
            "userId": "fa864d51-475e-4765-b3b4-12788525a3e6",
            "projectId": "u1M57XAwIiLpPwjp",
            "user": {
              "createdAt": "2025-09-16T16:13:20.056Z",
              "id": "fa864d51-475e-4765-b3b4-12788525a3e6",
              "email": "lindualdo@hotmail.com",
              "firstName": "Aldo",
              "lastName": "Santos",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-09-16T16:22:10.583Z",
                "personalization_survey_n8n_version": "1.108.1"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "jUAvu7DUAzyqZhJd",
                "userActivatedAt": 1758041156747,
                "easyAIWorkflowOnboarded": true,
                "dismissedCallouts": {
                  "preBuiltAgentsModalCallout": true
                },
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1759918723295
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": []
}
